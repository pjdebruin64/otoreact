<h1>HTML Elements</h1>
<p>All source elements that are not RHTML or user-defined constructs, build HTML elements.</p>
<p>All trailing dots in the tag name are removed.</p>
<p>Source attributes are compiled as described below.</p>

<h2>HTML Attributes</h2>
<p>All source attributes that do not fall in any of the categories below, are compiled as HTML attributes.
    <br>They may use <a href="#StringInterpolation">string interpolation</a>.
</p>
<demo #srctext=sampleSqrt></demo>


<h2>DOM Properties</h2>
<p>
    The browser translates attributes specified in HTML elements to <i>properties</i> of the corresponding DOM objects.
    <br>Rather than setting an attribute, RHTML allows you to directly set the DOM property, by prepending the property name with a hash mark and specifying a JavaScript expression: <code class=sourcecode>#<i>propertyName</i>="<i>expression</i>"</code>
</p>
<p>
    Note that while attributes always have string values, even when the content of the string is numeric, properties can have any type.
    <br>So by setting a property rather than an attribute, you avoid unnecessary type conversions, and you spare an attribute node in the created DOM tree.
    <br>Furthermore, there are some DOM properties that are not available as HTML attributes at all.
</p>
<p>
    Documentation of all properties can e.g. be found at <a href="{MDN}Web/API#interfaces">MDN</a> or at <a href="https://www.w3schools.com/jsref/default.asp">W3schools</a>.
</p>
<p>
    When the expression yields value <code>undefined</code> and the property had a string value, then the property is set to the empty string, because otherwise the DOM would turn <code>undefined</code> into the string "undefined".
</p>
<p>
    Notes: for properties with string values, setting <code>#<i>name</i>="<i>expr</i>"</i></code> has usually the same effect as <code><i>name</i>="\{<i>expr</i>}"</code>.
</p>
<p>
    For events, setting <code>on<i>name</i>="<i>script</i>"</code> is completely the same as <code>#on<i>name</i>="(event) => \{ <i>script</i> }"</code>.
    <br>Setting <code>#on<i>name</i>="<i>expr</i>"</code> is about the same as <code>on<i>name</i>="return (<i>expr</i>)(event)"</code>.
</p>

<h2>HTML DOM Events</h2>
<p>
    In HTML, attributes whose name starts with "on" are not normal attributes but event handlers: pieces of JavaScript that will be executed when some event happens.
    <br>They may contain the name <code>event</code> which represents an object containing more information about the event.
</p>
<p>
    In RHTML, this is exactly the same, see <code>onclick="x.V += 1"</code> in the demo above.
</p>
<ul>
    <li>
        RHTML event handler attributes do not have string interpolation; they are already JavaScript and braces have their normal JavaScript meaning.
    </li>
    <li>
        RHTML event handlers may contain RHTML local variables; these will be bound to their values. Assignments to these variables (but not to their properties) are ignored.
    </li>
    <li>
        As a bonus, the keyword <code>this</code> in RHTML event handlers is bound to the current HTMLElement object.
        <br>(So you don't have to write <code>event.target</code> or <code>event.currentTarget</code>.)
    </li>
</ul>


<h2>RHTML Non-DOM-events</h2>
RHTML implements some additional events that are not triggered by browser engine but by the OtoReact engine:
<dl>
    <dt><code class=sourcecode>oncreate</code></dt>
    <dd>
        Happens after an element (and its children) has been <i>created</i> (built).
    </dd>
    <dt><code class=sourcecode>onupdate</code></dt>
    <dd>
        Happens after an element (and its children) has been <i>updated</i>.
    </dd>
    <dt><code class=sourcecode>oncreateupdate</code> or <code class=sourcecode>onupdatecreate</code></dt>
    <dd>
        Happens after an element (and its children) has been <i>created</i> (built) <i>or updated</i>.
        <p>
            <code>create</code> may replaced by <code>*</code>, and <code>update</code> by <code>+</code>, so you may write <code>oncreate+</code> or <code>onupdate*</code> or even <code>on*+</code>.
            <br>The association of <code>*</code> with creation and <code>+</code> with updating is used with <a href="#TwoWayBinding">two-way bindings</a> as well.
    </dd>
</dl>
Note: The name <code>event</code> is not available in handlers for these pseudo-events, but <code>this</code> is.

<h3 id=onerror>RHTML error handlers</h3>
Normally, errors occuring in HTML event handlers are logged to the console and not handled otherwise, unless you explicitly add e.g. a try-catch construction to each and every error-prone event handler.
<p>
    RHTML allows you to set an error handler for <i>all</i> DOM events at once!
</p>

<dl>
    <dt><code class=sourcecode>onerror</code></dt>
    <dd>
        Happens whenever an error occurs in the following situations:
        <ul>
            <li>
                During any synchronous DOM event handler attached to the current element or any of its HTML children, including HTML elements created by RHTML components defined outside the current element
            </li>
            <li>
                During the asynchronous execution of a <code>Promise</code> returned by a DOM event handler.
                <br>So if your handler includes a call to some asynchronous function <code>doSomething</code>, then you must make sure that that it returns the resulting promise in order for asynchronous errors to be caught, e.g.: <code>onclick="return doSomething()"</code>
            </li>
            <li>
                While creating or updating the current element or its children
            </li>
            <li>
                While resolving an asynchronously defined local variable value, see <a href="#define"><elm>DEFINE</elm></a>.
            </li>
        </ul>
        The name <code>event</code> is bound to the error value (usually a string).
    </dd>
    <dt><code class=sourcecode>onerror-</code></dt>
    <dd>
        Happens in the first two situations listed for <code>onerror</code>, so not while creating or updating the element.
    </dd>
</dl>

<h2>Class Names</h2>
<p>
    "Class names" are used in HTML to select CSS styling rules from a stylesheet, and can of course be set with the <code>class</code> attribute or the <code>#className</code> DOM property.
    <br>Note that there is not (and cannot be) a <code>#class</code> DOM property, because 'class' is a reserved word in JavaScript.
</p>
<p>
    Besides these, RHTML recognizes the following attributes:
</p>
<dl>
    <dt><code class=sourcecode>#class:<i>name</i>="<i>booleanExpression</i>"</code></dt>
    <dd>or</dd>
    <dt><code class=sourcecode>#class.<i>name</i>="<i>booleanExpression</i>"</code></dt>
    <dd>
        Class name <i>name</i> will be added in lowercase to the element if and only if the expression evaluates to true (or another <a href="{MDN}Glossary/Truthy">truthy</a> value).
        <br>Note that the HTML parser transforms <i>name</i> into lowercase, so you cannot use this for class names containing uppercase characters.
    </dd>
    <dt><code class=sourcecode>+class="<i>expression</i>"</code></dt>
    <dd>
        When the value of the expression is a string, then it is added to the list of class names.
        <br>When it is an array, then every element of the array is added to the list of class names
        <br>When it is an object, then for every property <i>name</i> in the object, <i>name</i> will be included in the list of class names if and only if the property value is truthy.
    </dd>
</dl>
Just as other DOM properties, class names are recomputed at every update of the element.


<h2>Inline Styles</h2>
HTML, and hence RHTML, allow you set style properties of individual elements with the <a href="{MDN}Web/HTML/Global_attributes/style"><code>style</code> global attribute</a>. These are called "inline styles".
<br>The corresponding <a href="{MDN}Web/API/HTMLElement/style"><code>style</code> DOM property</a> yields the inline style as an object, but can't be set.
<br>One can, however, set its properties. RHTML recognizes the following attributes:
<dl>
    <dt><code class=sourcecode>style.<i>name</i>="<i>string</i>"</code></dt>
    <dd>
        Style property <i>name</i> will be set to <code><i>string</i></code>, applying string interpolation.
    </dd>
    <dt><code class=sourcecode>#style.<i>name</i>="<i>expression</i>"</code></dt>
    <dd>
        Style property <i>name</i> will be set to the value of <code><i>expression</i></code>.
        <p>When the value is <code>null</code>, empty, or <code>undefined</code>, then the style property will be reset.
        <p>When the value is <code>false</code>, then the style property will also be reset.
            <br>This allows you to abbreviate a conditional style setting like <code>#style.<i>name</i>="<i>cond</i> ? <i>expr</i> : null"</code> to <code>#style.<i>name</i>="<i>cond</i> &amp;&amp; <i>expr</i>"</code>
    </dd>
    <dt><code class=sourcecode>+style="<i>objectExpression</i>"</code></dt>
    <dd>
        The expression should evaluate to an object.
        <br>Every property <i>name</i> in the object will be set or reset in the inline style object.
    </dd>
</dl>
<demo #srctext=sampleInlineStyles></demo>


<h2 id=TwoWayBinding>Output and Two-way Bindings</h2>
DOM properties are not static but can change. RHTML allows four variants of output binding for properties to expressions that are valid 'assignment targets' (or 'left-hand side' expressions): <code>*</code>, <code>+</code>, <code>!</code> and <code>!!</code>.
<br>Valid assignment targets are expressions that can be assigned to: global variables, array elements, and object properties, including RVAR values.
<dl>
    <dt><code class=sourcecode>*<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        The assignment target receives the value of the property immediately after the element and its children have been <i>created</i>.
        <br>This is the same as setting a handler:
        <pre>oncreate="<i>assignmentTarget</i> = this.<i>propertyName</i>"</pre>
    </dd>
    <dt><code class=sourcecode>+<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        The assignment target receives the value of the property immediately after the element and its children have been <i>updated</i>.
        <br>This is the same as setting a handler:
        <pre>onupdate="<i>assignmentTarget</i> = this.<i>propertyName</i>"</pre>
    </dd>
    <dt><code class=sourcecode>!<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        The assignment target receives the value of the property at every <a href="{MDN}Web/API/HTMLElement/input_event">input event</a>.
        <br>This is the same as setting a handler:
        <pre>oninput="<i>assignmentTarget</i> = this.<i>propertyName</i>"</pre>
        <p>For elements which allow text input, an input event happens at every keystroke. You see the effect in several samples on this page.
    </dd>
    <dt><code class=sourcecode>!!<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        The assignment target receives the value of the property at every <a href="{MDN}Web/API/HTMLElement/change_event">change event</a>.
        <p>
            Note that only <elm>input</elm>, <elm>select</elm>, and <elm>textarea</elm> produce change events.
            <br>For elements which allow text input, a change event happens when the user presses ‹Enter› or when the element looses focus, so less often than input events.
        </p>
    </dd>
</dl>
These may be combined with each other and with <code>#<i>propertyName</i></code> to get two-way bindings, for example:
<pre>#!<i>propertyName</i>="<i>assignmentTarget</i>"</pre>
is the same as <code>#<i>propertyName</i>="<i>assignmentTarget</i>" !<i>propertyName</i>="<i>assignmentTarget</i>"</code>.
<br>So the property receives the value of the assignment target at element creation and update, <i>and</i> the assignment target receives the value of the property at every input event.

<p>Last but not least, there are two abbreviations:</p>
<dl>
    <dt><code class=sourcecode>@<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        This is the same as <code>#!<i>propertyName</i>="<i>assignmentTarget</i>"</code>.
        <br>So the property receives the value of the assignment target at element creation and update, <i>and</i> the assignment target receives the value of the property at every <i>input</i> event.
    </dd>
    <dt><code class=sourcecode>@@<i>propertyName</i>="<i>assignmentTarget</i>"</code></dt>
    <dd>
        This is the same as <code>#!!<i>propertyName</i>="<i>assignmentTarget</i>"</code>.
        <br>So the property receives the value of the assignment target at element creation and update, <i>and</i> the assignment target receives the value of the property at every <i>change</i> event.
    </dd>
</dl>
<p>
    These bindings are especially useful for the <code>value</code> or <code>checked</code> property of <a href="{MDN}Web/API/HTMLInputElement">input elements</a>, or the <code>textContent</code>, <code>innerText</code>, or <code>innerHTML</code> properties of elements with <code><a href="{MDN}Web/API/HTMLElement/contentEditable">contentEditable</a>=true</code>.
    <br>See the example in the <a href="#Persistence">Persistence paragraph</a>.
</p>
<p>Or you can use them to capture the innerHTML or outerHTML of an element:
</p>
<demo srctext='<def rvar=a></def>
<p *outerHTML="a.V">Hi</p>
<hr>
\{a.V}'></demo>