<h1>Other Subjects</h1>

<h2 id=URLRouting>URL routing</h2>
"URL routing" in a single-page application is about routing different URLs to seemingly different pages <i>without requesting them from the server</i>.
<br>
<a href="routing" #onclick=reroute>This routed page</a> tells you all about it.
<p>Here a summary of the OtoReact routing features:</p>
<dl>
    <dt><code>docLocation</code></dt>
    <dd reacton=docLocation>
        Predefined <a href="#RVAR">RVAR</a>, containing the current URL.
        <br>So its value <code>docLocation.V</code> is always equal to <code>location.href</code> (currently "{docLocation.V}").
        <p>It allows applications to react on changes in the URL, and you can set its value to navigate to a different URL while staying within the application.</p>
        <p>It has four additional properties and methods:</p>
        <dl>
            <dt><code>docLocation.basepath</code></dt>
            <dd>
                This property holds the <i>base path</i> of the application.
                <br>All relative URL's within an OtoReact aplication are considered relative to this base path, and it is used to determine the current subpath.
                <br>The current base path is "{docLocation.basepath}".
            </dd>
            <dt><code>docLocation.subpath</code></dt>
            <dd>
                Part of the current pathname after the base path.
                <br>For this page it is "{docLocation.subpath}" (empty); for the routing page "{new URL('routing', location.origin+docLocation.basepath).href}", it is "routing".
                <p>An application can use <a href="#PatternMatching">pattern matching</a> on this value to decode encoded special characters, capture parameters into variables, and show the correct page.
            </dd>
            <dt><code>docLocation.searchParams</code></dt>
            <dd>
                An <a href="{MDN}Web/API/URLSearchParams">URLSearchParams</a> object containing the current URL search parameters.
                <br>It is equivalent to <code>new URLSearchParams(location.search)</code>.
            </dd>
            <dt><code>docLocation.search(<i>key</i>, <i>value</i>)</code></dt>
            <dd>
                Returns a URL, equal to the current URL with search parameter <i>key</i> set to <i>value</i>, or with search parameter <i>key</i> removed when <i>value</i> is <code>null</code>.
            </dd>
        </dl>
    </dd>
    <dt><code>reroute</code></dt>
    <dd>
        Handler for the click-event for internal links, like <elm>a href="<i>href</i>" #onclick=reroute</elm>.
        <br>It causes clicks on the link to be intercepted, so that the application can change its state instead of sending a page request to the server.
        <p>
            Control-clicks are not intercepted and will open in a new browser tab.
        </p>
    </dd>
    <dt><code>reroute(<i>href</i>)</code></dt>
    <dd>
        Command to navigate the application to <i>href</i>, which may be an absolute or relative URL.
        <br>For absolute URLs, it is the same as <code>docLocation.V = <i>href</i></code>.
        <br>This is useful, e.g., for <elm>BUTTON onclick</elm> handlers.
    </dd>
    <dt id=basePattern><code>\{basePattern: &hellip;\}</code></dt>
    <dd>
        Compiler option, specifying a <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions">RegExp</a> to identify the part of the compile-time URL that constitutes the <a href=BasePath>base path</a>.
        <br>This is only needed for applications that want to use routing on subpathes containing slashes.
        <br>The initial part of the compile-time pathname up to and including the <i>last match</i> to this RegExp, constitutes the base path.
        <br>If there is no match, then the base path is empty.
        <p>The default basePattern is "/".
        <br>E.g., if an OtoReact application is loaded from URL "https://mydomain.org/myapplication/myroutedpage?query" and <code>basePattern</code> is not explicitly set, then <code>BasePath</code> is set equal to the initial part of pathname "/myapplication/myroutedpage" up to and including the last slash, which is "/myapplication/".
    </dd>
</dl>



<h2 id=StyleTemplate>Dynamic style sheets</h2>
The HTML parser does not allow string interpolation inside <elm>STYLE</elm>, but OtoReact allows to use <elm>STYLE.</elm> to define style sheets using string interpolation and RHTML constructs, like loops and conditionals.
<p>Some points of attention:</p>
<ul>
    <li>Braces inside <elm>STYLE.</elm> that are part of the style sheet and do not delimit an embedded string must be escaped: <code>\\{ \\}</code>.</li>
    <li>
        <elm>STYLE.</elm> style sheet templates have global effect just like <elm>STYLE</elm>, but may depend on local variables.
        <br>Hence they cannot be moved to the document header, so you must avoid having multiple possibly conflicting instances of the same style sheet.
        <br>E.g., don't put them inside a <elm>FOR</elm> loop.
    </li>
    <li>
        <elm>STYLE.</elm> sheets react on updates, but at every update, the sheet has to be rebuilt as a string, and parsed again by the browser.
        <br>So you may want to avoid unnecessary style sheet updates, by proper use of <code>reacton</code>.
    </li>
    <li>
        Sheets imported with <code><a href="{MDN}CSS/@import">@import</a></code> cannot use string interpolation.
    </li>
</ul>
<p>
    Here is a sample style sheet template that, upon pressing the button, gives all <elm>h2</elm> elements an identical random hue:
</p>
<demo #srctext=sampleStyleTemplate></demo>


<h4>External dynamic style sheets</h4>
If you want to use RHTML functionality in an external style sheet, then combine <elm>STYLE.</elm> with <elm>INCLUDE</elm>:
<pre class=sourcecode>
<{}style.>
    <{}INCLUDE src="yourStyleSheet.css"></{}INCLUDE>
<{}/style.>
</pre>

<h2>Formatting</h2>
OtoReact does not (yet) have extra formatting functionality for numbers and dates, etc. You can use standard JavaScript features like the <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Intl">Internationalization API</a>, or a library like <a href="https://day.js.org/">Day.js</a>.

<demo #srctext=sampleFormatting></demo>

<h2 id=Options>Options</h2>
When calling <code>RCompile(HTMLElement, options?)</code>, the <code>options</code> object may contain the following settings.
<style>
    table#tblOptions {
        margin: 1em 2em;
        border-collapse: collapse;
    }
    table#tblOptions tr > * {
        border: solid 1px var(--OtoRed);
        padding: 4px;
    }
    table#tblOptions th {
        font-weight: normal;
        font-style: oblique;
    }
    table#tblOptions > tbody  td:nth-child(1) {
        font-weight: bold;
    }
    table#tblOptions > tbody  td:nth-child(2) {
        font: var(--Code); color: darkblue; background-color: rgb(236, 236, 236);
        text-align: center;
    }
</style>
<table id=tblOptions>
    <thead><tr>
        <th>Name</th><th>Default</th><th>Description</th>
    </tr></thead>
    <tbody>
        <tr>
            <td>bTiming</td><td>false</td>
            <td>When true, OtoReact will write timing information to the JavaScript console for each compile, build or update action.</td>
        </tr>
        <tr>
            <td>bAbortOnError</td><td>false</td>
            <td>
                When true, building or updating the DOM will be aborted when any error occurs.
                <br>An error message will be written to the console and shown in an alert box.
                <br>Compile errors will always cause an abort, except within <elm>RHTML</elm> text.
            </td>
        </tr>
        <tr>
            <td>bShowErrors</td><td>true</td>
            <td>
                When true, errors while building or updating the DOM will be included in the DOM output, besides being written to the console.
            </td>
        </tr>
        <tr>
            <td>bDollarRequired</td><td>false</td>
            <td>
                When true, a dollar sign is required before <a href="#StringInterpolation">string interpolation</a> braces, and no backslash is needed before other braces within interpolated text.
            </td>
        </tr>
        <tr>
            <td>bSetPointer</td><td>true</td>
            <td>When true, OtoReact will add style 'cursor: pointer' to any element that has a non-null <code>onclick</code> handler.</td>
        </tr>
        <tr>
            <td>basePattern</td><td>"/"</td>
            <td>
                Regular expression to identify the part of the URL that constitutes the <a href=#BasePath><i>base path</i></a>, see <a href="#basePattern">basePattern</a>.
                <br>Relevant only for applications that use <a href=#URLRouting>URL routing</a>.
            </td>
        </tr>
        <tr>
            <td>preformatted</td><td>[ ]</td>
            <td>
                By default, OtoReact will skip white space when it reckons it is irrelevant for the visual appearance of the page. Only within the preformatted <elm>pre</elm> element white space is always preserved.
                <br>With the 'preformatted' option, you can set an array of other (case insensitive) element names that should have all white space preserved in the DOM.
                <br>You may need to use this when you have set the <a href="{MDN}Web/CSS/white-space"><code>white-space</code> CSS property</a> so that white space is not collapsed for other elements.
            </td>
        </tr>
        <tr>
            <td>bKeepWhiteSpace</td><td>false</td>
            <td>
                When true, <i>all</i> white space will be preserved in the DOM output.
            </td>
        </tr>
        <tr>
            <td>bKeepComments</td><td>false</td>
            <td>
                When true, comments in the RHTML code will be included in the DOM output.
            </td>
        </tr>
    </tbody>
</table>
Example: <code>RCompile(document.body, \{bTiming: true, preformatted: ['quote'], } );</code>


<h2>Search engine compatibility</h2>
<i>Dynamic</i> content generated by a JavaScript framework, or just any client-side JavaScript code, can only be indexed by a search engine if that engine is able to execute the JavaScript.
<br>Now Google does a very good job at executing JavaScript, and will probably be able to index your OtoReact site, provided each page has its own URL and is reachable through normal links.
<br>Most other engines, including Bing I think, won't do so.

<p>
    <i>Static</i> content in an OtoReact <i>main file</i>, on the other hand, is just HTML and can be indexed by any search engine.
    This is an advantage over frameworks like Angular and Svelte, where <i>all</i> content is generated by JavaScript.
</p>
<p>
    Static content in <i>included files</i> can only be loaded throught JavaScript, and can only be indexed by search engines executing JavaScript.
    <br>If you want your static content be split over multiple files Ã¡nd want it to be indexable by any search engine, you could think of the following solutions:
</p>
<ul>
    <li>
        Use server-side technology, like Server Side Includes (SSI) or PHP, to include files in your main file.
    </li>
    <li>
        Use a tool to bundle multiple OtoReact files into a single file before deployment. <!-- Like Webpack? -->
        <br>Such a tool is not available yet, but it's not difficult to develop one.
    </li>
</ul>

<h2>Playground(s)</h2>
Here you have a playground to enter your own Reactive HTML.
<p>
    All code you enter will be saved by your browser in <a href="{MDN}Web/API/Web_Storage_API">localStorage</a>, and should be available when you return to this page.
</p>

<def rvar=playCount #value=1 store=localStorage></def>
<react on=playCount>
    <def var=Playgrounds #value="Array.from(range(playCount.V)).map(i => RVAR(`Playground${i}`,'',localStorage))" updating></def>
    <for let=rvar of="Playgrounds" index key=index>
        <demo #rvar="rvar"></demo>
    </for>
    <button onclick="playCount.V++">
        Add another playground
    </button>
    <if cond="playCount.V > 1">
        <button onclick="playCount.V--; Playgrounds[playCount.V].V=''; Playgrounds.length = playCount.V">
            Remove last playground
        </button>
    </if>
</react>
