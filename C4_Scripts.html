<h1 id=Scripts>&lt;SCRIPT&gt;</h1>
<p>
    Scripts can be included almost anywhere in your application, either embedded or through an external <code>src</code> reference.
</p>
<p>
    You have to be aware that scripts included in the main document, except those tagged with <code>nomodule</code>, are automatically executed by the browser before OtoReact has had any opportunity to intervene.
</p>
<p>
    You have also to be aware that scripts in browser-based JavaScript come in two flavours: <i>classic</i> JavaScript and JavaScript <i>modules</i>, and that OtoReact is imported as a JavaScript module.
</p>
<ul>
    <li>
        Scripts in the main document file with just <elm>SCRIPT</elm> are treated as <u>classic</u> JavaScript.
        <br>That means that they will be executed as soon as they are parsed, and that is <i>before</i> OtoReact has been loaded.
        <br>So they cannot execute OtoReact functions like <code>RVAR</code>, until OtoReact has been loaded.
        <br>On the other hand, names defined in a classic script are automatically put in the global environment and are available in RHTML code.
    </li>
    <li>
        Scripts in the main document file with <elm>SCRIPT type=module</elm> are treated as a JavaScript <u>module</u>.
        <br>That means that it will be executed after the whole document has been parsed and, assuming that you call OtoReact at the top of your document, <i>after</i> OtoReact has been loaded and has compiled your document, but before the document has been built.
        <br>So one can immediately call OtoReact functions like <code>RVAR</code>.
        <br>On the other hand, names defined in a JavaScript module are not automatically put in the global environment. You have to explicitly define them as properties of the global object: <code class=sourcecode>window.<i>name</i> = &hellip;</code> or <a href="{MDN}Web/JavaScript/Reference/Global_Objects/globalThis">better</a>: <code class=sourcecode>globalThis.<i>name</i> = &hellip;</code> before they are available in RHTML code.
    </li>
    <li>
        Scripts included through <elm>INCLUDE</elm> or <elm>IMPORT</elm>, or inside <elm>RHTML</elm> dynamic code like the code demo's in this document, or with a <code>nomodule</code> attribute, work still different.
        <br>These are not encountered and executed by the browser at all. Instead, they are executed by OtoReact during compilation in <a href="{MDN}">strict mode</a>.
        <br>That means that OtoReact functions are available, names are not automatically global, but module functionality like <code>import</code> is not available, not even when you add <code>type=module</code>.
        <p>
            In this case, OtoReact will look for an attribute <code><elm>SCRIPT defines="<i>nameList</i>"</elm></code>, specifying a comma-separated list of names defined inside the script.
            <br>OtoReact will make these names available to your RHTML code.
            <br>(Currently as global names, later on as local variables.)
        </p>
        <p>
            These scripts may not be external yet, <code>src</code> is ignored.
        </p>
    </li>
    <li>
        If you don't want the distinction between scripts in the main file and scripts in included files, <b>you can always use <elm>SCRIPT nomodule</elm></b>.
        <br>These are always skipped by the browser, and always executed by OtoReact.
    </li>
</ul>

<p>
    To waylay hackers of this website, JavaScript names <code>fetch</code>, <code>XMLHttpRequest</code>, and <code>import</code> are not available in scripts within the editable demo's on this page.
    <br><code>eval</code> is redefined to access the global environment only.
</p>