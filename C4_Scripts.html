<h1>Other Subjects</h1>

<h2 id=URLRouting>URL Routing</h2>
"URL routing" in a single-page application is about routing different URLs to seemingly different pages <i>without requesting them from the server</i>.
<br>
<a href="routing" #onclick=reroute>This routed page</a> tells you all about it.
<p>Here a summary of the OtoReact routing features:</p>
<dl>
    <dt><code>RootPath</code></dt>
    <dd>
        Global variable containing the <i>root path</i> of the current application.
        <br>All relative URL's within an OtoReact aplication are considered relative to this root path, and it is used to determine the current subpath.
    </dd>
    <dt><code>docLocation</code></dt>
    <dd reacton=docLocation>
        Predefined <a href="#RVAR">RVAR</a>, containing the current URL.
        <br>So its value is always equal to <code>location.href</code> (currently "{docLocation.V}").
        <p>It allows applications to react on changes in the URL.
    </dd>
    <dt><code>docLocation.subpath</code></dt>
    <dd>
        Part of the current pathname after the root path.
        <br>For this page it is "{docLocation.subpath}" (empty); for the routing page "{new URL('routing', location.origin+RootPath).href}", it is "routing".
        <p>An application can use <a href="#PatternMatching">pattern matching</a> on this value to decode encoded special characters, capture parameters into variables, and show the correct page.
    </dd>
    <dt><code>reroute</code></dt>
    <dd>
        Handler for the click-event for internal links, like <elm>a href="<i>href</i>" #onclick=reroute</elm>.
        <br>It causes clicks on the link to be intercepted, so that the application can change its state instead of sending a page request to the server.
    </dd>
    <dt><code>reroute(<i>href</i>)</code></dt>
    <dd>
        Command to navigate the application to <i>href</i>. It is the same as <code>docLocation.V = <i>href</i></code>.
        <br>This is useful for <elm>BUTTON onclick</elm> handlers.
    </dd>
    <dt><code>\{rootPattern: &hellip;\}</code></dt>
    <dd>
        Compiler option, specifying a <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions">RegExp</a> to identify the part of the compile-time URL that constitutes the root path.
        <br>This is only needed for applications that want to use subpathes containing slashes.
        <br>The initial part of the compile-time pathname up to and including the <i>last match</i> to this RegExp, constitutes the root path.
        <p>The default rootPattern is '/|^'.
        <br>E.g., if an OtoReact application is loaded from URL "{document.location.origin}{RootPath}routing" and <code>rootPattern</code> is not explicitly set, then <code>RootPath</code> is set equal to the initial part of pathname "{RootPath}routing" up to and including the last slash, which is "{RootPath}".
    </dd>
</dl>



<h2 id=StyleTemplate>Dynamic style sheets</h2>
The HTML parser does not allow string interpolation inside <elm>STYLE</elm>, but OtoReact allows to use <elm>STYLE.</elm> to define style sheets with string interpolation. Some points of attention:
<ul>
    <li>Braces inside <elm>STYLE.</elm> that are part of the style sheet and do not delimit an embedded string must be escaped: <code>\\{ \\}</code>.</li>
    <li>
        <elm>STYLE.</elm> style sheet templates have global effect just like <elm>STYLE</elm>, but may depend on local variables.
        <br>Hence they cannot be moved to the document header, so you must avoid having multiple possibly conflicting instances of the same style sheet.
        <br>E.g., don't put them inside a <elm>FOR</elm> loop.
    </li>
    <li>
        <elm>STYLE.</elm> sheets react on updates, but at every update, the sheet has to be rebuilt as a string, and parsed again by the browser.
        <br>So you may want to avoid unnecessary style sheet updates, by proper use of <code>reacton</code>.
    </li>
    <li>
        Sheets imported with <code><a href="{MDN}CSS/@import">@import</a></code> cannot use string interpolation.
    </li>
</ul>
<p>
    Here is a sample style sheet template that, upon pressing the button, gives all <elm>h2</elm> elements an identical random hue:
</p>
<demo #content=sampleStyleTemplate></demo>


<h2>Formatting</h2>
OtoReact does not (yet) have extra formatting functionality for numbers and dates, etc. You can use standard JavaScript features like the <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Intl">Internationalization API</a>, or a library like <a href="https://day.js.org/">Day.js</a>.

<demo #content=sampleFormatting></demo>

<h2 id=Options>Options ...</h2>

<h2>Playground(s)</h2>
Here you have a playground to enter your own Reactive HTML.
<p>
    All code you enter will be saved by your local browser in <a href="{MDN}Web/API/Web_Storage_API">localStorage</a>, and should be available when you return to this page.
</p>

<def rvar=playCount #value=1 store=localStorage></def>
<react on=playCount>
    <def rvar=Playgrounds #value="Array.from(range(playCount.V)).map(i => RVAR(`Playground${i}`,'',localStorage))" updating></def>
    <for let=rvar of="Playgrounds.V" index key=index>
        <demo #rvar="rvar"></demo>
    </for>
    <button onclick="playCount.V++">Add another playground</button>
    <if cond="playCount.V > 1">
        <button onclick="playCount.V--; Playgrounds.V[playCount.V]=undefined">Remove one playground</button>
    </if>
</react>