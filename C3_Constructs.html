<h1>RHTML Constructs</h1>

N.B. All construct attributes which must be JavaScript expressions, like <code>cond</code> and <code>of</code>, may <i>optionally</i> be prefixed with a hash mark: <code>#cond</code>, <code>#of</code>.
<br>Their meaning remains the same.

<p>
    Any attribute starting with an underscore "_" is ignored like comment. So one can use this to insert a comment right between attributes (<code>_="Some comment"</code>), or to comment out attributes.
</p>

<p>
    Any construct may have an attribute 'hidden', making it invisible while it is being compiled. (This isn't needed, of course, when the application root node is hidden, see <a href="#DocSetup">Document setup</a>.)
</p>

<p>
    Otherwise, it is an error when a construct instance has unknown attributes.
</p>

<h2 id=DEFINE><{}DEFINE var #value>, Local Variables</h2>
<pre class=sourcecode>
<elm>DEFINE var=<i>name</i> #value="<i>expression</i>"</elm><elm>/DEFINE</elm>
</pre>
<p>
    introduces a local <u>immutable</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>Alternatively, one can give an interpolated string: <code>value="<i>string</i>"</code>.
    So for an expression, the '<code>#</code>' is required.
    <br>The variable is visible in all local expressions from the <elm>DEFINE</elm> till the end of the enclosing element, except when obscured by nested definitions.
    <br>It cannot be assigned to, but when its value is an RVAR or some other object, then one can of course modify its properties.
</p>
<p>
    The expression is, by default, evaluated only once, when the respective DOM-trunk is built, not when it is updated.
</p>
<p>
    When you add an attribute <code class=sourcecode>updating</code> or <code class=sourcecode>reacting</code> (without value), then the expression is re-evaluated at every update.
</p>
<p>
    <elm>DEFINE</elm> may not have any child nodes, other than comments or white space.
</p>
<p>
    <elm>DEFINE</elm> may be abbreviated to <elm class=sourcecode>DEF</elm>.
</p>
<p id=lexicalScoping>
    Local variable names (including loop variables and component parameters) obey strict <a href="{wiki}Scope_(computer_science)#Lexical_scope">lexical scoping</a> rules:
</p>
<demo #srctext=demoScoping></demo>

<h3 id="def-rvar"><{}DEFINE rvar #value></h3>
<pre class=sourcecode><elm>DEFINE rvar=<i>name</i> #value?="<i>expression</i>" store?=<i>storage</i> storename?=<i>storeName</i> onmodified?=<i>handler</i> auto?=true</elm><elm>/DEFINE</elm></pre>
<p>
    introduces a local <u>reactive</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>This is similar to <code><elm>DEFINE var=<i>name</i> #value="RVAR(null, <i>expression</i>, <i>storage</i>, <i>storeName</i>)"</elm><elm>/DEFINE</elm></code>, see <a href=#RVAR>RVAR's</a>.
</p>
<p>
    One can use <code>value="<i>string</i>"</code> instead of <code>#value="<i>expression</i>"</code>, as before.
</p>
<p>
    When <i>expression</i> yields a <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>, then the value of the rvar wil initially be <code>undefined</code>, and once the promise resolves to a value, then the rvar will be set to that value.
</p>
<p>
    When <code class=sourcecode>store</code> is specified, then the rvar value is stored in the given storage, see <a href=#Persistence>Persistence</a>.
</p>
<p>
    When <code class=sourcecode>updating</code> or <code class=sourcecode>reacting</code> is specified, the expression is re-evaluated and the RVAR is set at every update, but the RVAR <u>won't be re-created</u>, so any existing subscribers to the RVAR remain subscribed.
</p>
<p>
    When <code class="sourcecode">onmodified</code> is specified, the given handler will be subscribed to the new RVAR, i.e., the handler will be executed whenever the RVAR has been modified or otherwise been set dirty.
</p>
<p>
    When <code class="sourcecode">auto=false</code> is set, then auto-subscription (see below) is disabled.
    The default is determined by RHTML <a href="#Options">option</a> <code>bAutoSubscribe</code>, which defaults to <code>true</code>.
</p>


<h4 id="auto">RVAR auto-subscription*</h4>
When an RVAR is declared using <elm>DEFINE rvar</elm>, and auto-subscription is enabled, and no subscriber (like a <code>reacton</code> attribute refering to the RVAR)
was found while either compiling or building the range of HTML following the <elm>DEFINE</elm>,
then OtoReact will <i>automatically subscribe</i> that whole range where the RVAR is visible.
<p>
    Here you have two RVAR's <code>a</code> and <code>b</code>, each followed by a button and a span element.
    <br><code>a</code> has no explicit subscriber, so both elements are auto-subscribed to <code>a</code> and are updated when you click the button.
    <br>The second span is subscribed to <code>b</code>, so there is no auto-subscription and the second button won't be updated when you click it.
</p>
<demo #srctext="demoAutoSubscribtion"></demo>

<h3><{}DEFINE rvar @value>*</h3>
<pre class=sourcecode><elm>DEFINE rvar=<i>name</i> @value?="<i>expression</i>" onmodified?=<i>handler</i></elm><elm>/DEFINE</elm></pre>
introduces a local <u>two-way</u> reactive variable. "<i>Expression</i>" must be a <a href="#TwoWayBinding">valid assignment target</a>, and whenever the new RVAR has been set dirty, its value will be assigned to <i>expression</i>.
<p>
    One can use this to bind a reactive variable <code><i>name</i></code> to some part of another reactive variable <code><i>x</i></code>, say <code><i>x</i>.U.someprop[i]</code>.
    When one uses <code><i>x</i>.U</code> to refer to the value of <code><i>x</i></code>, then <code><i>x</i></code> is marked dirty whenever <code><i>name</i></code> is marked dirty.
</p>
<p>
    Here is a small example &mdash; where the defined RVAR <code>num</code> is not really useful, because there is only a single reference to it:
</p>
<demo #srctext=demoTwoWayRVAR></demo>

<h2 id=CASE><{}CASE> <{}WHEN cond> <{}ELSE></h2>
<pre class=sourcecode>
<{}CASE hiding?>
    <{}WHEN cond="<i>expr</i>"> <i>WhenPart</i> <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre> is a conditional piece of RHTML.
<ul>
    <li>
        There may be multiple <elm>WHEN</elm> parts.
    </li>
    <li>
        The first <i>WhenPart</i> for which the value of <i>expr</i> is true (or <a href="{MDN}Glossary/Truthy">truthy</a>), is included in the document.
    </li>
    <li>
        If none is truthy, and there is an <elm>ELSE</elm> part, then <i>ElsePart</i> is included.
    </li>
    <li>
        When <code class=sourcecode>hiding</code> is specified, then <i>all</i> alternatives will be included in the DOM tree, but the unwanted ones will be <a href="{MDN}HTML/Global_attributes/hidden">hidden</a>.
        <br>This may result in slower initial building, but faster switching between alternatives (especially when using <a href="#GlobalAtts"><code>thisreactson</code></a>).
    </li>
</ul>
<h3 id=PatternMatching>Pattern Matching</h3>
Furthermore, <elm>CASE</elm> can select an alternative based on <i>pattern matching</i> against a given string value.
<p>Substrings of the value can be captured into new local variables.
<p>There are three variants of patterns:
</p>
<pre class="sourcecode">
<{}CASE #value="<i>expr</i>">
    <{}WHEN match="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN urlmatch="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN regmatch="<i>regExp</i>" captures?="<i>nameList</i>"> &hellip; <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
All three variants are case-insensitive, and all can be combined with a simple condition <code>cond</code>.
<dl>
    <dt><code>match="<i>pattern</i>"</code></dt>
    <dd>
        The value is matched against the given 'simple pattern', which may contain the following wildcards:
        <ul>
            <li><code>?</code> matches any single character</li>
            <li><code>*</code> matches any string of characters</li>
            <li><code>[<i>charString</i>]</code> matches any character in <i>charString</i>, where all <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">rules for JavaScript character classes</a> apply</li>
            <li>
                <code>\{ <i>varName</i> \}</code> matches non-greedily any string of characters, and 
                <ul><li>
                    The matched string will be captured in <a href=#Variables>local variable</a> <i>varName</i>
                </li></ul>
            </li>
            <li><code>\</code> followed by any character matches just that character</li>
        </ul>
        The whole value has to match, not just a substring.
    </dd>
    <dt><code>urlmatch="<i>pattern</i>"</code></dt>
    <dd>
        This form is meant to be matched against (parts of) an URL, and is useful for routing.
        <br>The recognized patterns are the same simple patterns as above, but any substring captured in a local variable will be <a href="{wiki}Percent-encoding">URL-decoded</a>.
    </dd>

    <dt><code>regmatch="<i>regExp</i>" captures?="<i>nameList</i>"</code></dt>
    <dd>
        <i>regExp</i> can be any JavaScript <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Cheatsheet">regular expression pattern</a>.
        <p>The match succeeds when a substring of the string value matches against <i>regExp</i>.</p>
        <p>When <code>captures="<i>nameList</i>"</code> is specified, then the values captured by any <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">capturing groups</a> in the pattern will be stored in local variables with the specified names, in order of appearance. Use empty names to skip unneeded capturing groups.</p>
    </dd>
</dl>
Patterns with captures cannot be combined with <code>hiding</code>, as no DOM-tree can be built when the variable values are unknown.


<h2 id=IF><{}IF cond> <{}THEN> <{}ELSE></h2>
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <i>ThenPart</i>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
or
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <{}THEN> <i>ThenPart</i> <{}/THEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
is the same as:
<pre>
<{}CASE>
    <{}WHEN cond="<i>expr</i>"> <i>ThenPart</i> <{}/WHEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
<p>
    All hiding and pattern-matching features of <elm>CASE</elm><elm>WHEN</elm> apply to <elm>IF</elm> as well.
</p>


<h2 id=FOR><{}FOR let of index?></h2>
<pre class="sourcecode">
<{}FOR let=<i>name</i> of="<i>iterableExpression</i>">
    <i>BodyPart</i>
<{}/FOR>
</pre>
<p>
    The normal FOR-construct repeats its <i>BodyPart</i> for each item yielded by the value of <i>iterableExpression</i>.
</p>
<p>
    The value of <i>iterableExpression</i> must be an <a href="{MDN}Web/JavaScript/Reference/Statements/for...of">iterable object</a>, e.g. an Array, or the result of the RHTML <a href="#rangeFunction">range function</a>, if you want a numeric repetition. 
</p>
<p>
    Attribute <code>let=<i>name</i></code> (or <code>var=<i>name</i></code>) is compulsory, but <i>name</i> may be missing or empty. When nonempty, <i>name</i> becomes a local (immutable) variable bound to the respective item.
</p>

<demo #srctext="sampleParticipants">
</demo>

Further on, <elm>FOR</elm> can have the following attributes:
<dl>
    <dt><code>index=<i>indexName</i></code></dt>
    <dd>
        When present, <i>indexName</i> becomes a local variable bound to the zero-based index number: 0 for the first item, 1 for the second, and so on.
        <br>When <code>index</code> is present but <i>indexName</i> omitted, then <code>index='index'</code> is assumed.
    </dd>

    <dt><code>previous=<i>prevName</i></code></dt>
    <dd>
        When present, <i>prevName</i> becomes a local variable bound to the <i>preceeding</i> item in the iteration, or <code>undefined</code> for the first item.
        <br>This allows one to easily check for changed properties within the iteration.
        <br>When <i>prevName</i> is omitted, then <code>'previous'</code> is assumed.
    </dd>
    
    <dt><code>next=<i>nextName</i></code></dt>
    <dd>
        In the same way, <i>nextName</i> becomes bound to the <i>next</i> item in the iteration.
    </dd>

    <dt><code>key="<i>keyExpression</i>"</code></dt>
    <dd>
        When a FOR-construct has to be updated, items in the iteration may have been removed, added, reordered, or replaced.
        <br>OtoReact does not make any assumption about these items; it will by default completely rebuild the FOR DOM-tree on every update.
        <p>
            You may however specify a <i>keyExpression</i>, which may refer to <i>name</i> and <i>indexName</i> and should compute a unique "key" value for each item in the iteration.
            <br>In that case OtoReact will use this to identify old and new items. When an item in a new iteration has the same key value as an item in the previous iteration, then OtoReact won't rebuild its DOM-tree, but will move its previous DOM-tree to its (possibly) new position and will update it in-place.
            <br>This has the following effects:
        </p>
        <ul>
            <li>It is faster</li>
            <li>If any input element in the tree had received focus or inputdata, then it will keep that focus or data</li>
            <li>Any <code>oncreate</code> handlers won be executed again</li>
            <li>If the RHTML in <i>BodyPart</i> created any RVAR's or other objects, then these won't be renewed but will keep their previous value</li>
        </ul>
        <p>
            When items in the iteration are always distinct, then the key may be the item itself: <code>key=<i>name</i></code>.
            <br>When items in the iteration always remain in place, then the key may be the index number: <code>key=<i>indexName</i></code>
        </p>
    </dd>

    <dt><code>hash="<i>hashExpressionList</i>"</code></dt>
    <dd>
        Processing can be further speeded up by specifying one or more comma-separated "hash expressions".
        <br>OtoReact cannot quickly detect whether some property (deep) inside an object has changed, so it will by default update all subtrees when updating the FOR-construct, meaning it will recompute all properties, conditions, et cetera.
        <p>
            If, however, you specify a <i>hashExpressionList</i>, then OtoReact will assume an item (identified by its key) has not changed when the values of the expressions in <i>hashExpressionList</i> haven't changed, and it won't spend time on updating its DOM subtree.
        </p>
        <p>
            The hash expression need not be a real <a href="{wiki}Hash_function">hash function</a>; it could be a possibly long string.
            <br>If, e.g., items are read from an external source and parsed using <code>JSON.parse</code>, then one could preserve the unparsed string and use it as the hash value.
        </p>
    </dd>

    <dt><code>reacting</code> (or <code>reactive</code>)</dt>
    <dd>
        The loop variable <i>name</i> is immutable, but events may modify its properties. If you need the DOM subtree to react on property changes, then you can add attribute <code>reacting</code> (or <code>reactive</code>) to make <i>name</i> reactive.
        <p>
            When <code>reacting</code> is present, then <i>name</i> gets a property <code><i>name</i>.U</code>, which yields the value of <i>name</i> and marks it as dirty, just as with <a href="#RVAR">reactive variables</a>.
            <br><i>Name</i> does not become a full RVAR: one cannot get or set <code><i>name</i>.V</code>. One could call it an RVAR-light.
        </p>
        <p>
            Note that just <i>name</i> is marked dirty, not the source (array) of the iteration. If you need elements of your application <i>outside</i> the local subtree to react on changes, then you can use the <code>updates</code> attribute described below.
        </p>
    </dd>
    <dt><code>updates="<i>rvarList</i>"</code></dt>
    <dd>
        If you want changes to properties of <i>name</i> to have reactions outside the local subtree, then you can use <code>updates="<i>rvarList</i>"</code>.
        <br><i>rvarList</i> must be a comma-separated list of zero or more RVAR's.
        <p>
            When present, then <i>name</i> becomes reacting as above, and whenever <i>name</i> is marked dirty (by a reference to <code><i>name</i>.U</code>), then all RVAR's in <i>rvarList</i>> will be marked dirty too.
        </p>
        <p>You can find an example of this in the todo-list below: whenever an item is (un)marked as done, then both lists that depend on <code>TODO</code> are updated.</p>
    </dd>
</dl>

<h2 id=SCRIPT><{}SCRIPT type? src? defines?></h2>
<p>
    Scripts can be included almost anywhere in your application, either embedded or through an external <code>src</code> reference.
</p>
<p>
    External scripts may be written in <a href="https://www.typescriptlang.org/">TypeScript</a>, of course.
</p>
<p>
    You have to be aware that scripts included in the main document, except those tagged with <code>nomodule</code>, are automatically executed by the browser before OtoReact has had any opportunity to intervene.
</p>
<p>
    You have also to be aware that scripts in browser-based JavaScript come in two flavours: <i>classic</i> JavaScript and JavaScript <i>modules</i>, see <a href="{MDN}Web/HTML/Element/script">MDN</a>, and that OtoReact is imported as a JavaScript <a href="{MDN}Web/JavaScript/Guide/Modules"><i>module</i></a>.
</p>
<p>
    Outside the main document, both classic and module scripts will be executed by OtoReact, and OtoReact adds a number of extra options.
    <br>Together, you have the following alternatives:
</p>
<h4>Regular classic/module scripts</h4>
These are the two regular forms of JavaScript.
<dl>
    <dt><elm>SCRIPT src?</elm> or <elm>SCRIPT type="<b>text/javascript</b>" src?</elm></dt>
    <dd>
        <ul>
            <li>
                When these elements occur <i>in the main document file</i>, the browser will execute the internal or external script as <u>classic</u> JavaScript <i>while parsing the file</i>.
                <br>That is <i>before</i> OtoReact has been loaded, so it cannot immediately execute OtoReact functions like <code>RVAR</code>.
                <br>Any names defined in the script are automatically put in the global scope and are available in RHTML code.
                <br>One can use <a href="{MDN}Web/JavaScript/Reference/Strict_mode">strict mode</a> by placing the statement <code>"use strict";</code> or <code>'use strict';</code> (including the quotes) at the beginning of the script.
                <br>One can add <code>async</code> or <code>defer</code> as described on <a href="{MDN}Web/HTML/Element/script">MDN</a>.
            </li>
            <li>
                <i>Outside</i> the main file, in included or imported RHTML files, OtoReact will execute the internal or external script as classic JavaScript <i>while compiling the file</i>.
                <br>OtoReact functions are available.
                <br>OtoReact tries to mimick  browser behaviour, but it cannot detect which names have been defined, and does not automatically put them in global scope. You need to explicitly define them as properties of the global object, or switch to <elm>SCRIPT type="otoreact" defines?="<i>nameList</i>"</elm>.
                <br>One can use strict mode as above.
                <br>With attribute <code>async</code>, fetching and executing is done asynchronously, and awaited for when the respective DOM tree is being built.
                <br>With attribute <code>defer</code>, execution is defered till, and awaited for, the first time the DOM tree is being built.
            </li>
        </ul>
    </dd>

    <dt><elm>SCRIPT type="<b>module</b>" src?</elm></dt>
    <dd>
        <ul>
            <li>
                When this element occurs <i>in the main document file</i>, the browser will asynchronously execute the internal or external script as a JavaScript <u>module</u>. Multiple module scripts are executed in order of appearance.
                <br>That means that it will be executed after the whole document has been parsed and, assuming that you import and call OtoReact at the top of your document, <i>after</i> OtoReact has been loaded and has compiled your document, but <i>before</i> the document has been built.
                <br>To execute OtoReact functions, one can either import the functions from OtoReact.js, or invoke them from global scope.
                <br>Names defined in a JavaScript module are not automatically put in the global scope. You have to explicitly define them as properties of the global object: <code class=sourcecode>window.<i>name</i> = &hellip;</code> or <a href="{MDN}Web/JavaScript/Reference/Global_Objects/globalThis" title="What is globalThis?">better</a>: <code class=sourcecode>globalThis.<i>name</i> = &hellip;</code> before they are available in RHTML code.
                <br>Modules use strict mode automatically.
            </li>
            <li>
                <i>Outside</i> the main file, OtoReact will asynchronously execute the script as a JavaScript module, and await for it when building the DOM tree.
            </li>
        </ul>
    </dd>
</dl>

<h4>OtoReact-supported classic JavaScript</h4>
These are three forms of classic JavaScript with OtoReact features.
<br>Strict mode is involed automatically.
<dl>
    <dt><elm>SCRIPT type="<b>otoreact</b>" src? defines?="<i>nameList</i>"</elm>,
        <br><elm>SCRIPT type="<b>otoreact/global</b>" src? defines?="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously fetches the internal or external script, and executes it once as <i>classic</i> JavaScript <i>the first time the DOM tree is being built</i>.
        <br>Names are not automatically defined in global scope, but one can provide a comma-separated <code>defines="<i>nameList</i>"</code> telling which names should be put in global scope.
    </dd>  
    
    <dt><elm>SCRIPT type="<b>otoreact/local</b>" src? defines?="<i>nameList</i>" updating?</elm></dt>
    <dd>
        This type of script is executed <i>every time</i> the surrounding RHTML is being <i>built</i>.
        <br>With attribute <code class="sourcecode">updating</code>, the script is executed every time the surrounding RHTML is being built <i>or updated</i>.
        <br>Local variables from the surrounding RHTML are visible inside the script, and names listed in <i>nameList</i> are defined as new OtoReact <i>local variables</i>.
        <p>
            So when this type of script is used inside a component template, then each instance of the component will have its own set of data.
        </p>
    </dd>
    
    <dt><elm>SCRIPT type="<b>otoreact/static</b>" src? defines="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously fetches the internal or external script, and executes it <i>once</i> as <i>classic</i> JavaScript <i>the first time the DOM tree is being built</i>.
        <br>Names listed in <i>nameList</i> are not put in global scope, but are defined as OtoReact <i>local variables</i>.
        <p>
            So when this type of script is used inside, e.g., a component, then the script is executed just once, the values of the listed names are internally remembered, and visible as local variables just inside the component.
        </p>
    </dd>  
</dl>

<h4>OtoReact-supported JavaScript modules</h4>
These are two forms of JavaScript modules with OtoReact features.
<dl>
    <dt><elm>SCRIPT type="<b>otoreact; type=module</b>" src? defines?="<i>nameList</i>"</elm>
        <br><elm>SCRIPT type="<b>otoreact/global; type=module</b>" src? defines?="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously executes the internal or external script as a JavaScript <u>module</u>.
        <br>Fetching and executing the script is initiated when compiling the containing file, and is awaited for when first building the DOM tree.
        <br>When a <i>nameList</i> is given, then the script is required to <u>export</u> the listed names, and OtoReact will define them <i>in global scope</i>.
    </dd>
    <dt><elm>SCRIPT type="<b>otoreact/static; type=module</b>" src? defines="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously executes the internal or external script as a JavaScript <u>module</u>.
        <br>Fetching and executing the script is initiated when compiling the containing file, and awaited for when first building the DOM tree.
        <br>The script is required to export the names listed in <i>nameList</i>, and OtoReact will define them <i>as OtoReact local variables</i>.
    </dd>
</dl>

<h2 id=REACT><{}REACT on?></h2>

<p>
<pre class=sourcecode>
<elm>REACT</elm>
    <i>Content</i>
<elm>/REACT</elm></pre>
    allows you to group a range of source nodes, limit the scope of local variables, add <a href="#GlobalAtts">global attributes</a>, and set <a href="#PseudoEvents">pseudo events</a>, without adding other functionality.       
</p>
<p>
    <elm class=sourcecode>REACT on=<i>RVAR-list</i></elm> is a shorthand for <elm>REACT reacton=<i>RVAR-list</i></elm>.
</p>

<h2>Introduction to Components</h2>
<p><elm>COMPONENT</elm> defines a new user-defined construct, or custom element.</p>

<p>We start with a gentle introduction into components, which is followed by a full descripion of all concepts and features, and some more examples.</p>

<h3>Signatures, templates, and instances</h3>

<script type="otoreact" defines="signat,templ,compTimes,demoTimes">
let signat=`<TimesTable #rows #factor></TimesTable>`,
    templ=
`<div>
    <FOR let=x of="range(1, R)">
        <div>{x} x {F} = {x * F}</div>
    </FOR>
</div>`,
    compTimes =
`<COMPONENT>

    <SIGNATURE>
        ${signat}
    </SIGNATURE>

    <TEMPLATE #rows=R #factor=F>
${Indent(templ,8)}
    </TEMPLATE>

</COMPONENT>`,

demoTimes =
`${compTimes}

Here you have a small times table:
<TimesTable #rows="5" #factor="2"></TimesTable>

<def rvar=factor store=sessionStorage></def>
<p>
    What other times table do you want?
    <input type=number style="width:8ex" @value="factor.V">
</p>

<if cond="factor.V > 0">
    <TimesTable #rows="10" #factor="factor.V"></TimesTable>
</if>
`;
</script>

<p>
    Suppose one wishes to insert a single multiplication table (or 'times table') on multiple places within one application.
    <br>Then one could want to define a construct <i>(1)</i>:
<pre #innerhtml='ColorCode(signat)'></pre>
    that is to be replaced by the output of <i>(2)</i>:
<pre #innerhtml='ColorCode(templ)'></pre>
where <code>R</code> and <code>F</code> are JavaScript variables representing the values of the construct properties <code>#rows</code> and <code>#factor</code>.

<p>
    HTML expression (1) is called the component '<i>signature</i>', RHTML code (2) is called its '<i>template</i>', and <code>#rows</code> and <code>#factor</code> are called its '<i>parameters</i>'.
</p>
<p>
    Such a construct can be defined by writing:
</p>
<pre #innerhtml='ColorCode(compTimes)'></pre>

<p>The SIGNATURE tags may be omitted.</p>

<p>The new construct can subsequently be used like:</p>
<pre #innerhtml='ColorCode(`<TimesTable #rows="5" #factor="2"></TimesTable>`)'></pre>
This is called an '<i>instance</i>' of the construct.

<p>Instances are fully reactive:</p>
<demo #srctext="demoTimes" #tab="false"></demo>


<h3>Parameters</h3>
There are several kinds of parameters, like interpolated strings, JavaScript expressions, event handlers, two-way parameters. These are further described described in the section on <a href="#Signatures">Signatures</a>.

<p>In all cases, parameters represent <i>data</i>.</p>

<h3>Slots</h3>
Besides parameters, components can have <i>slots</i>.
<p>Slots represent not data, but a small or large <i>document part
    
</i>, including document markup, or even a reactive sub-application.
<br>A component slot is like a placeholder, to be filled by the user of the component. So an instance of the component must provide definitions of the actual values of the component slots. These definitions are actually templates just like component templates.
</p>

<p>Slots can have parameters and slots themselves ('subslots'). So a slot is itself characterized by a signature, just as a component.</p>

<p>Inside a component, slots can be instantiated just like used-defined constructs. So in OtoReact, we have three types of constructs:</p>
<ul>
    <li>Those defined by OtoReact itself, like <elm>DEFINE</elm>, <elm>CASE</elm>, and <elm>COMPONENT</elm></li>
    <li>Constructs defined by the user by means of <elm>COMPONENT</elm></li>
    <li>Inside a (component or slot) template: constructs corresponding to the slots of the construct that's being defined by the template</li>
</ul>

<p>Now note:</p>
<ul>
    <li>A construct <i>signature</i> contains a <i>signature</i> of each contruct slot</li>
    <li>A construct <i>template</i> can contain <i>instances</i> of each construct slot</li>
    <li>A construct <i>instance</i> can contain <i>templates</i> for each construct slot</li>
</ul>


<h3>Content slots</h3>
A component instance may contain content (text and elements) that does not correspond to any slot name.
The component definition can use this spurious content as well by including a <i>content slot</i>, which is a slot named "CONTENT" or starting with "CONTENT".
All instance content not corresponding to any slot slot name forms a template for this content slot.

<p>
    For example, to define a construct <elm>ablank</elm> that just creates an <elm>a</elm> element with an extra <code>target="_blank"</code> attribute, one writes:
</p>
<pre #innerhtml='ColorCode(
`<COMPONENT>
    <!-- Component signature: -->
    <ablank ...args>
        <CONTENT></CONTENT>     <!-- Slot signature -->
    </ablank>

    <!-- Component template -->
    <TEMPLATE ...args>
        <a ...args target="_blank"><content></content><!-- Slot instance --></a>  
    </TEMPLATE>
</COMPONENT>`)'></pre>

Notes:
<ul>
    <li>There may be at most one content slot</li>
    <li>Naturally, slots (other than content slots) can have a content slot as well</li>
    <li>Content slots can have (non-content) slots as well, see the <a href="#Radiogroup">Radiogroup example</a></li>
</ul>


<h2 id=COMPONENT><{}COMPONENT recursive? encapsulate?></h2>

<p>A component definition consists of a component <i>signature</i>, optionally one or more style sheets, scripts, local definitions etc., and finally a component <i>template</i>:
<pre class=sourcecode>
<{}COMPONENT recursive? encapsulate?>

  <{}SIGNATURE> <i>Signature</i> <{}/SIGNATURE>
  <comm>or just:</comm>
  <i>Signature</i>

  <{}STYLE &hellip;> &hellip; <{}/STYLE>&hellip;
  <{}SCRIPT &hellip;> &hellip; <{}/SCRIPT>&hellip;
  <{}DEFINE &hellip;> &hellip; <{}/DEFINE>&hellip;

  <{}TEMPLATE &hellip;> <i>Template</i> <{}/TEMPLATE>
  
<{}/COMPONENT>
</pre>
<ul>
    <li>
        The <a href=#Signatures><i>signature</i></a> describes how invocations of the component (or construct), called '<i>instances</i>', look like. The signature may specify <i>parameters</i> and <i>slots</i>.</li>
    <li>
        The <a href=#Templates><i>template</i></a> describes what content should be generated for each component instance. Inside the template, parameters are available as JavaScript variables, and slots are available as RHTML constructs. So the template may contain instances of the slots.</li>
    <li>
        In between signature and template any RHTML content is allowed, but is advisable to use only declarative content, as above, or invisible content, like a <elm>datalist</elm> that is to be shared among all instances of the component.
    </li>
    <li>
        <a href=#Instances><i>Instances</i></a> may or must specify values for each parameter, and contain blocks of RHTML code (or actually <i>templates</i>) for each slot.
    </li>
    <li>
        With attribute <code class="sourcecode">recursive</code>, the component can be <i>recursive</i>: the template may contain instances of the component itself. Also see <a href="#MutualRecursion">Mutual recursion</a>.
    </li>
    <li>
        With attribute <code class="sourcecode">encapsulate</code>, the generated content will be <i>encapsulated</i>, meaning mainly that the component can contain its own styling rules, independent of the main document.
        See <a href=#Encapsulate>encapsulate</a> for details.
    </li>
    <li>
        Component templates can contain nested component definitions.
    </li>
    <li>
        Component templates can use local variables defined outside of the component.
        <br>So a nested component definition can use the parameter values of the outer component.
    </li>
</ul>
<p>
    Note: RHTML component templates and slots are not the same as <a href="{MDN}Web/Web_Components">HTML web component templates and slots</a>. It's the same idea but a different syntax and implementation, that is much simpler and at the same time much more powerful.
</p>


<h3 id=Signatures>Signatures</h3>
<p>
    The first element inside <elm>COMPONENT</elm> is its signature.
    <br>It is <em>optionally</em> surrounded by <elm>SIGNATURE</elm>.
    <br>E.g.:
    <pre #innerHTML="ColorCode(C1)"></pre>
    <ul>
        <li>
            The tag name of the signature element ('Repeat' in this example) defines the (case-insensitive) name of the component.
        </li>
        <li>
            Attributes like <code><i>name</i></code>, <code>#<i>name</i></code>, or <code>@<i>name</i></code> of the signature element define the <b>parameters</b> of the component.
            <br>Instances of the component must have the same attributes, and these correspond to local variables inside the component template.
            <p>There are special cases:</p>
            <ul>
                <li>
                    Attributes with a question mark <code><i>name?</i></code> or with a nonempty default value <code><i>name</i>="<i>string</i>"</code> or <code><i>#name</i>="<i>expression</i>"</code> define <b>optional parameters</b>.
                    <ul>
                        <li>
                            When an instance doesn't have this attribute, or when the initial parameter value is <code>undefined</code>, then the specified default string or expression is used instead.
                        </li>
                        <li>
                            An empty string <code><i>name</i>=""</code> is not recognized as a default value, because the HTML parser does not distinguish between a missing value and the empty string.
                            <br>To specify the empty string as default value, one must use an empty string <i>expression</i>, like: <code>#<i>name</i>=" '' "</code>.
                        </li>
                        <li>
                            Component parameter defaults can refer to global and local variables.
                        </li>
                        <li>
                            Parameter defaults are evaluated each time the component is instantiated and the parameter value is <code>undefined</code>.
                        </li>
                        <li>The default default value is <code>undefined</code>.</li>
                    </ul>
                </li>
                <li>
                    Attributes <code><i>name</i></code> where <i>name</i> starts with "on" represent <b>event handlers</b>.
                    <br>Values are compiled as JavaScript, and the default default value is the empty handler.
                </li>
                <li>
                    Attributes <code>@<i>name</i></code> define <b>two-way parameters</b>.
                    <br>Their values must be <a href="#TwoWayBinding">valid assignment targets</a>.
                </li>
                <li>
                    An attribute prefixed with three dots <code>...<i>name</i></code> is a <b>rest parameter</b>. It must be the last parameter.
                    <br>All instance attributes that do not match a normal parameter, nor an RHTML <a href="#GlobalAtts">global attribute</a> or <a href="#PseudoEvents">pseudo-event</a>, are collected into this rest parameter, which can be passed on to an HTML element.
                </li>
            </ul>
        </li>
        <li>
            Each child element of the signature element defines a <i>slot</i> of the component.
            <br>These child elements are themselves signatures: slot signatures.
            <p>
                For each slot, component instances may have one or more child elements that should match the slot signature.
                <br>The slots are available <i>as constructs</i> within the component template.
            </p>
            <p>
                When building a component instance, the content of any instance child element that matches a slot name becomes the (slot) template for the slot instances within the component template
            </p>
            <p>
                As slots have signatures, they can have parameters and slots themselves.
                <br>Slot parameter defaults may not yet refer to local variables (because slot templates are evaluated in a different environment than the slot signature).
            </p>
        </li>
        <li>
            Slot names starting with "CONTENT" are special. When a component signature contains such a <elm>CONTENT*</elm> slot, then all content of a component instance that does not match any other slot, forms a template for this special slot.
        </li>
        <li>There may be at most one such content slot.</li>
    </ul>
</p>

<h3 id=Templates>Templates</h3>
The component template is tagged <elm>TEMPLATE</elm>, and must be the last element child of <elm>\COMPONENT</elm>. E.g.:
<pre #innerHTML="ColorCode(C2)"></pre>
<ul>
    <li>
        Parameters of the component (like <code>count</code>) are available <u>as local variables</u> inside the template.
    </li>
    <li>
        The value of the local variable <i>name</i> representing a two-way parameter <code>@<i>name</i></code> will be a new RVAR for each created instance of the component.
        <br>The RVAR value <code><i>name</i>.V</code> will be the value of the assignment target provided in the instance, and whenever a new value is assigned to the RVAR, that value will be assigned to the assignment target as well.
    </li>
    <li>
        Parameter names <u>may</u> be repeated in the template tag, like <elm>TEMPLATE #count</elm> or <elm>TEMPLATE count</elm>.
        <br>Or they may specify a local variable name, like: <elm>TEMPLATE #count=Count</elm>. This is useful when you want to have uppercase characters in the local variable name, because the parameter name itself, being an attribute name, is always seen as lowercase by the parser.
    </li>
    <li>Slots of the component (<elm>content</elm> in this case) are available <u>as constructs</u> inside  the template</li>
    <li>The template of a component with slots may contain <a href="#FORoverSlots">a special kind of FOR-loop</a> which iterates over the slot templates</li>
</ul>

<h3 id=Instances>Instances</h3>
A component is instantiated by a tag containing the component name:

<pre #innerHTML="ColorCode(C3)"></pre>

<h4>Parameter values</h4>
A component instance may/must have attributes that provide values for all optional/compulsory parameters of the template. There are four forms:
<ul>
    <li>By default, the value is specified as an interpolated string: <code><i>name</i>="<i>string</i>"</code></li>
    <li>When the name is prefixed with a hash mark, the value is computed as a JavaScript expression: <code>#<i>name</i>="<i>expression</i>"</code></li>
    <li>
        When <i>name</i> starts with "on", then the value is specified as a block of JavaScript statements, just like an event handler: <code><i>name</i>="<i>statements</i>"</code>
        <br>The value of the parameter will be the routine <code>function(event) \{ <i>statements</i> \}</code>.
    </li>
    <li>
        The value provided for a two-way parameter <code>@<i>name</i></code> must be a valid <a href="#TwoWayBinding">assignment target</a>.
    </li>
    <li>
        As with standard constructs, attribute names starting with an underscore "_" are ignored.
    </li>
</ul>
<p>
    When the component has a rest parameter, then the values specified by any remaining attributes are collected into that rest parameter. Otherwise it is an error when there are remaining attributes.
</p>

<h4>Slot templates</h4>
The component instance may contain templates for each of the slots of the component. So just as the component definition contains a component template that can be instantiated by a client, so the component instances may contain slot templates that can be instantiated within the component template.
<ul>
    <li>
        Slot templates are tagged by the slot name (not by <elm>template</elm>)
    </li>
    <li>
        Slot templates must be direct children of the component instance. They are to be recognized at compile time, so they cannot be inside a <elm>CASE</elm> or some other construct.
    </li>
    <li>
        When the slot signature contains parameters, then these names <u>must</u> be repeated in the slot template tag.
    </li>
    <li>There may be multiple templates for the same slot. By default these are concatenated.</li>
    <li>
        When the component signature contains the special slot name <elm>content</elm>, then all content of the component instance that is not some (other) slot template, forms a template for the <elm>content</elm> slot.
    </li>
</ul>

Now in this case, the slot is named <elm>content</elm> indeed, so we can shorten the component instance to:
<pre #innerHTML="ColorCode(C4)"></pre>
</pre>
Note how the instance tag <elm>repeat</elm> carries both  the component parameter value <code>#count=7</code> and the <elm>content</elm> slot parameter name <code>#num</code>.

<p>Putting it all together, we get:</p>
<demo #srctext=sampleComponent1 #tab="-1"></demo>


<h3 id="MutualRecursion">Mutual recursion</h3>
With the attribute <code class="sourcecode">recursive</code>, the component template(s) may contain instances of the component itself. There is an <a href="#RecursiveSample">example</a> below.
<p>
    <i>Mutual recursion</i> between components means a series of <u>multiple</u> component definitions that may contain <u>instances of each other</u>.
</p>
<p>
    Mutual recursion is possible by combining multiple signatures and multiple templates within a single <elm>COMPONENT</elm> definition, like this:
<pre #innerHTML="ColorCode(`<COMPONENT recursive>

    <SIGNATURES>
        <Comp1 …> … </Comp1>
        …
        <Compn …> … </Compn>
    </SIGNATURES>
    …
    <TEMPLATES>
        <Comp1 …> … </Comp1>
        …
        <Compn …> … </Compn>
    </TEMPLATES>

</COMPONENT>`)"></pre>
Notes:
<ul>
    <li>Each template is tagged by its component name.</li>
    <li>There must be exactly one template for each signature.</li>
    <li>This form of defining multiple components at once is possible for non-recursive components as well.</li>
</ul>


<h3 id=Encapsulate>Encapsulate*</h3>
The <elm>COMPONENT</elm> tag may have an attribute <code class="sourcecode">encapsulate</code>.
<ul>
    <li>
        <i>Without</i> <code>encapsulate</code>, instances of the component are <i>replaced</i> by the output of the component template.
        <p>Any styling rules of the surrounding document apply to the component output as well, and vice versa.
        <br>To make styling rules apply only to the component content, use CSS class names.
    </li>
    <li>
        <i>With</i> <code>encapsulate</code>, <elm>COMPONENT</elm> defines a new <i>custom element</i>.
        <br>The output of the component template defines the appearance of the element, but is encapsulated inside, using the so-called <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>.
        <p>
            Any styling rules of the surrounding document do not apply to the encapsulated content, and vice versa. The component can have its own style sheet(s), independent of the main document.
            <br>Styling rules and inline styles specifically targeted at the custom element, however, are inherited by the encapsulated content.
        </p>
        <p>
            The internally generated custom element name is <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">required to contain a hyphen</a>.
            If the component name does not already contain a hyphen, then a prefix 'rhtml-' is prepended.
            <br>This concerns the generated output only, component instances use just the component name, but styling rules targeted at the custom element must use the prefix.
        </p>
    </li>
</ul>


<h3>More examples</h3>
<h4>To-do application</h4>
Here is a to-do application, which splits the collection of items into those done and not done. We use a component <elm>itemlist</elm> to show such a filtered list.

<p>
    (Click on <button class=demo disabled>Component</button> to see or edit the component definition.)
</p>
<demo #srctext=sampleTODO>
</demo>

<h4 id="RecursiveSample">A recursive component</h4>
<p>Components may be recursive, i.e. refer to themselves, when the attribute <code>recursive</code> is specified.
<br>Here is a recursive component, which images a JavaScript nested list of lists:</p>
<demo #srctext=sampleRecursion></demo>

<h4 id="Redefining">Redefining HTML elements</h4>
<p>Components may redefine HTML elements. To refer to the original element, add a dot to the tag name.
<br>Here is a component that redefines <elm>a</elm> to ensures that all links with no target and an external href, get a <code>target='_blank'</code> attribute:</p>
<demo #srctext=sampleRedefineA>
</demo>
To instantiate the original <elm>a</elm> HTML element, write <elm>a.</elm>.

<h4>Slots within slots*</h4>
<p>As there are no restrictions on slot signatures, slots can have slots themselves (subslots). So when a component template instantiates a slot, it may provide templates for its subslots, and these subslots can be instantiated within the slot templates of a component instance.
    <br>This is particularly useful for components with a <elm>CONTENT</elm> slot. The component may provide new or redefined constructs, that are available only within the contents of component instances, and that may provide interaction with the component.
</p>
<p>
    This documentation website uses such subslots to redefine <elm>H1</elm>, <elm>H2</elm> within the context of a particular page, so that the given section titles are automatically entered into the table of contents of that page.
</p>


<h4 id="Radiogroup">A radio group component*</h4>
HTML provides radio buttons <elm>input type=radio</elm> bearing a name and a fixed value, and buttons with the same name constitute a group.
<br>When they are within a <elm>form</elm>, and the form is submitted to the web server, then the value of the currently selected button within each group is sent to the server.

<p>
    For a reactive application, using <elm>form</elm> works a bit clumsily.
    <br>The following custom component does a much better job; it allows one to bind an RVAR, or any other object property, directly to the selected radio button value, without needing a <elm>form</elm> and without repeating any code.
</p>

<demo #srctext="sampleRadioGroup"></demo>
Let me explain the somewhat complicated <elm>radiogroup</elm> signature.
<ul>
    <li>
        <elm>radiogroup</elm> has a parameter 'name' which will be the common name of all radio buttons in the group, and a two-way parameter '@value', that will provide <i>and</i> receive the value of the selected radio button.
    </li>
    <li>
        <elm>radiogroup</elm> has a slot <elm>content</elm> so that the component output can include the content of any radiogroup instance.
    </li>
    <li>
        Slot <elm>content</elm> has itself a slot <elm>radiobutton</elm>, that will be available as a new construct <i>anywhere</i> within the radiogroup instance contents.
    </li>
    <li>
        <elm>radiobutton</elm> has parameter '#value' that defines the value of the current button, and an optional 'onclick' handler so that component instances can specify this handler without overwriting the 'onclick' handler set by the component template, and a rest parameter '...rest' that will be passed on to the <elm>input type=radio</elm> radio button element.
    </li>
    <li>
        <elm>radiobutton</elm> has a slot <elm>content</elm>, that defines the label content for the current button.
    </li>
</ul>


<h2 id=FORoverSlots><{}FOR of> over component slots</h2>
When a custom construct (a component or a slot) has a slot <i>slot</i>, then instances of the construct may provide multiple templates for that slot.
<br>Now, inside the construct template, one can write:
<pre class=sourcecode>
<{}FOR of=<i>slot</i>>
    <i>Body</i>
<{}/FOR>
</pre>
When this template is instantiated, <i>Body</i> will be repeated for each provided <i>slot</i> template, and <i>slot</i> instances inside <i>Body</i> will be replaced by the output of just that template, rather than by the concatenation of all <i>slot</i> templates.
<p>
Here is a component which allows one to define tables column by column:
</p>
<demo #srctext=sampleTableMaker></demo>


<h2 id=INCLUDE><{}INCLUDE src></h2>
<code class=sourcecode><elm>INCLUDE src="<i>URL</i>"</elm><elm>/INCLUDE</elm></code>
allows you to include another RHTML file as if it were inserted into the main file.
<ul>
    <li>
        If the <elm>INCLUDE</elm> element has any content other than comments or whitespace, then that content is processed and <i>URL</i> is ignored.
        <br>(This allows a preprocessor to combine all files into one file.)
    </li>
    <li>
        Otherwise, the file is fetched from <i>URL</i> and compiled <i>asynchronously</i>: compiling the main file will continue while the included file is being fetched.
    </li>
    <li>
        <i>URL</i> may not use string interpolation, because the URL is needed at compile time.</p>
    </li>
    <li>
        <i>URL</i> may be a relative URL. In that case it is interpreted relative to the location of the <i>current</i> HTML file.
    </li>
</ul>

<p>
    To speed things up, you can insert a <a href="{MDN}Web/HTML/Link_types/preload">preload</a> link in the main document header:
</p>
<pre>
<{}link rel=preload href="<i>URL</i>" as=fetch crossorigin>
</pre>
("<code>crossorigin</code>" seems incorrect, but Google Chrome requires it.)

<h4>Using Server Side Includes</h4>
<p>
    A drawback of using <elm>INCLUDE</elm> may be that not all search engines will see the content of the included file.
    <br>Some engines, including Google, do execute JavaScript and will see the full document as it is built by OtoReact, while others won't.
    <br>So if you want all search engines to see the content of your document, then do not use <elm>INCLUDE</elm>.
    <br>An alternative might be to use server-side technology like <a href="{wiki}Server_Side_Includes">Server Side Includes</a> (SSI) to include your file, if your server supports it.
</p>
<p>
    It is possible to use both types of inclusion at once, if you have e.g. a production server that supports SSI and a development environment that does not:
</p>
<pre #innerHTML='ColorCode(`<include src="includefile.html">
    <`+`!--#include file="includefile.html"-->
</include>`)'></pre>
<ul>
    <li>
        In an environment that does not support SSI, the second line is ignored as a comment, and OtoReact will fetch the file and include its content.
    </li>
    <li>
        In an environment that supports SSI, the server will include the file in place of the second line, and:
        <ol>
            <li>All search engines will see its content</li>
            <li>OtoReact will process the included content rather than fetching the file separately.</li>
        </ol>
    </li>
</ul>


<h2 id=MODULE><{}MODULE id?></h2>
<elm>MODULE</elm> encapsulates a <em>module</em>: a series of components, definitions, and other content, that can be imported at other places using <elm>IMPORT</elm>.
<p>A <elm>MODULE</elm> can either be saved in a separate file, or be included anywhere in the importing file, for example by using a server-side-include.
<br>It may even be concatenated to the importing file; the HTML parser will insert it inside the document body.</p>


<h2 id=IMPORT><{}IMPORT src defines? include?></h2>
<pre class=sourcecode>
<{}IMPORT async? src="<i>src</i>" defines?="<i>nameList</i>" include?>
    <i>Signatures</i>
<{}/IMPORT>
</pre>
imports a number of components and variables defined in a <a href="#MODULE">module</a>.
<p>
    The module may reside either:
</p>
<ul>
    <li>Anywhere in the current file with an <code>id</code> being exactly equal to <i>src</i></li>
    <li>Or in a separate file loaded from URL <i>src</i>. In this case, the <elm>MODULE</elm> tag is optional.
    </li>
</ul>
There are two variants:
<ul>
    <li>
        With the <code class=sourcecode>async</code> option, the <elm>IMPORT</elm> element must contain full signatures of the imported components.
        <br>Compiling the document will continue with the provided signatures while the external file is being asynchronously fetched and compiled.
        <br>Only when one of the components has to be instantiated, will OtoReact wait for the completion of the import.
        <p>The listed signature need not be identical to, but must be 'compatible' with the external signature:</p>
        <ul>
            <li>All parameters and slots of the listed signature must be present in the external signature;</li>
            <li>Any optional parameter of the listed signature must be optional in the external signature too;</li>
            <li>Any missing parameter of the listed signature must be optional in the external signature;</li>
            <li>Slots of the external signature must be compatible with the corresponding slots of the listed signature, when present;</li>
            <li><u>Default values</u> need not be specified; Otoreact will always use the values provided in the <u>external</u> signature.</li>
        </ul>
    </li>
    <li>
        Without the <code>async</code> option, the <elm>IMPORT</elm> element needs only specify the names of the imported components.
        <br>The import may specify a signature but it will be ignored.
        <p>Compiling will still continue asynchronously, but as soon as the compiler encounters an invocation of one of the imported components, it will wait for the external file and get the signatures from there.
        <br>So one can import from multiple modules one after another, and these will still be fetched in parallel.
    </li>
</ul>
Furthermore:
<ul>
    <li>
        Local variables from the main file are not visible within the module.
    </li>
    <li>
        When there is an attribute <code class=sourcecode>defines="<i>nameList</i>"</code>, then the names in the list, which must be defined as local variables in the module, are made available as local variables in the importing RHTML code.
    </li>
    <li>
        Any <elm>style</elm> definitions in the source module are added to the main document (even those within non-imported components, currently).
    </li>
    <li>
        Any non-declarative content of the module file is normally ignored.
        <br>If, however, the attribute <code class=sourcecode>include</code> is specified, then all content is instantiated at the place of the <elm>IMPORT</elm> element.
        <p>
            This is mainly useful for invisible content, like the definition of pop-up windows and datalists.
        </p>
    </li>
    <li>
        The same module may be imported at multiple places, and will be fetched and compiled only once, provided the URL is spelled exactly the same.
    </li>
</ul>
Again, to speed things up, you can insert a <code>preload</code> link in the main document header.

<demo #srctext="demoModule"></demo>


<h2 id="STYLE"><{}STYLE scope? src?>: Static style sheets</h2>
All <elm>STYLE</elm> elements within RHTML code are moved by OtoReact to the document header at compile time, so they won't get lost or duplicated.
<p>It is not possible to use any OtoReact constructs or interpolated text inside <elm>STYLE</elm>, because the browser HTML parser allows only contents that conforms to the CSS specification.</p>
<p>OtoReact recognizes, however, two extra attributes:</p>
<dl>
    <dt><code class="sourcecode">scope="local"</code></dt>
    <dd>
        With <code>scope="local"</code>, the style sheet and the RHTML code that follows it are modified so that the sheet is effective in local scope only: all its <a href="{MDN}Web/CSS/CSS_Selectors">CSS selectors</a> will match only with HTML elements that are created by the subsequent RHTML code till the closing tag of its parent element.
        <p>
            In particular, if you place such a sheet within a component definition, then it will apply to the HTML content created by the component template, and by components defined locally within that component, but not to HTML content created by components called from that template but defined elsewhere.
        </p>
        <demo #tab="-1" srctext=
'<component>
    <marked><content></content></marked>
    <STYLE scope=local>
        div \{ color: red; font-weight: bold; }
    </STYLE>
    <template>
        <div><content></content></div>
    </template>
</component>

<marked>This <\{}div> is marked.</marked>
<div>This <\{}div> is not.</div>'
        ></demo>
        <p>This works by adding a new unique class name to all CSS selectors and to all created HTML elements.</p>
        <p>
            Note: <code>scope="local"</code> applies to some but not all <a href="{MDN}Web/CSS/At-rule">at-rules</a>:
        </p>
        <ul>
            <li>It works with conditional group rules (<code>@media</code>, <code>@supports</code>, <code>@document</code>);</li>
            <li>It does not apply to sheets imported with <code>@import</code>;</li>
            <li>Styling features (like <code>@font-face</code>, <code>@keyframes</code>, and <code>@counter-style</code>) cannot be localized by means of class names, and are left alone.</li>
        </ul>
    </dd>
    <dt><code class="sourcecode">src="<i>URL</i>"</code></dt>
    <dd>
        With <code>src="<i>URL</i>"</code>, OtoReact inserts the content of the external style sheet fetched from <i>URL</i>. This can be combined with <code>scope</code>.
        <p>
            Without <code>scope</code>, the result is the same as using <code><{}rhead><{}link rel="stylesheet" href="<i>URL</i>"><{}/rhead></code> or as <code><{}style>@import <i>URL</i><{}/style></code>.
        </p>
        <p>
            When <elm>STYLE</elm> has both non-trivial content and a <code>src</code> attribute, then <code>src</code> is ignored, just like <a href="#INCLUDE"><elm>INCLUDE</elm></a>, so that one can use server-side-includes to optionally insert the contents of the external file.
        </p>
    </dd>
</dl>


<h2 id="RSTYLE"><{}RSTYLE scope? src?>: Dynamic style sheets</h2>
While <elm>STYLE</elm> sheets are static, <elm>RSTYLE</elm> allows you to build <i>dynamic</i> style sheets using string interpolation and RHTML constructs, including loops, conditionals, and use of local variables.
<ul>
    <li>The sheet contents is evaluated at run time, and the resulting <elm>style</elm> sheet is inserted in the document, and updated or removed when needed.</li>

    <li>Braces <code>\{ \}</code> inside <elm>RSTYLE</elm> are treated as part of the style sheet; to use string interpolation you must add a dollar sign <code>$\{ \}</code>.</li>

    <li><elm>RSTYLE</elm> supports <code>scope</code> and <code>src</code> just as <elm>STYLE</elm>.</li>

    <li>Other attributes,like <a href="{MDN}Web/HTML/Element/style#attributes"><code>media</code></a>, are compiled as usual and applied to the created <elm>style</elm> element.</li>
</ul>
<p>
    Here is a sample style sheet template that, upon pressing the button, gives all <elm>h2</elm> elements an identical random hue, without needing inline styles:
</p>
<demo #srctext=sampleStyleTemplate></demo>

<p>Some points of attention:</p>
<ul>
    <li>
        When <elm>RSTYLE</elm> style sheet templates are placed inside a <elm>FOR</elm> loop, or inside a component template, then multiple, possibly different, instances of the same style sheet template may be created.
        <br>For efficiency reasons you should avoid this, unless you really mean to have multiple distinct instances.
    </li>
    <li>
        <elm>RSTYLE</elm> sheets react on updates, but at every update, the sheet has to be rebuilt as a string, and parsed again by the browser.
        <br>So you may want to avoid unnecessary style sheet updates, by proper use of <code>reacton</code> or <code>hash</code>.
    </li>
    <li>
        Note that <elm>STYLE.</elm> has exactly the same result as <elm>RSTYLE</elm> without scope, except that literal braces inside <ELM>STYLE.</ELM> must be escaped like <code>\\{ }</code>.
    </li>
</ul>
Here is a sample component where each instance has its own local stylesheet:
<demo #srctext="demoLocalRstyles" #tab="-1"></demo>


<h2 id="ELEMENT"><{}ELEMENT #tagname>*</h2>
<elm>ELEMENT #tagname="<i>expression</i>"</elm> builds an HTML element whose tagname is the string value of <i>expression</i>.
<br>All other attributes and child contents are passed on to the new element.

<p>The tagname may not be empty, and updates to the tagname of a created element are ignored.</p>

<demo srctext="<for let=t of=&quot;['b', 'i', 'u', 's', 'q', 'sup', 'sub', 'code']&quot;>
    <ELEMENT #tagname=&quot;t&quot;>TEST</ELEMENT>
</for>"></demo>

<h2 id="ATTRIBUTE"><{}ATTRIBUTE #name value>*</h2>
<elm>ATTRIBUTE #name="<i>expression</i>" value</elm> adds an attribute, whose name is the string value of <i>expression</i>, to its (nearest) parent HTML element.
<br>There may not be any child contents.

<p>When the value is null or empty, no attribute is added.</p>
<p>Updates to the attribute name are handled accordingly.</p>

<demo srctext=
'<def rvar=aName></def>
<def rvar=aValue value="80"></def>

Choose attribute:
<select @value=aName.V size=3>
	<option>width</option>
	<option>height</option>
    <option>title</option>
</select>
= <input @value="aValue.V">

<p>
<canvas style.backgroundcolor=ivory>
    <ATTRIBUTE 
		#name="aName .V" 
		#value="aValue.V"
	></ATTRIBUTE>
</canvas>'></demo>


<h2 id="COMMENT"><{}COMMENT>*</h2>
<code class=sourcecode><{}COMMENT><i>contents</i><{}/COMMENT></code>, where <i>contents</i> is any RHTML code, inserts a dynamically generated HTML Comment node in the DOM tree.

<p>Comments are invisible in the rendered document, but one can see the generated content by inspecting the DOM tree. One could use this to inspect the value of variables without showing them.</p>

<p>There is a demonstration of this in the <a href="#RHTML-demo">RHTML demo</a> below.</p>

<p>Note that comments <code><{}!-- <i>comment text</i> --></code> in the source text won't be included in the created DOM tree, unless <a href="#options">option</a> <code>bKeepComments</code> is set.</p>

<h2 id=RHTML><{}RHTML #srctext>*</h2>
<code class=sourcecode><{}RHTML><i>sourceCode</i><{}/RHTML></code>
or
<code class=sourcecode><{}RHTML #srctext="<i>sourceExpr</i>"><{}/RHTML></code>
allow you to interpret dynamically generated text as Reactive HTML.
<p>After each build or update, when the text value of <i>sourceExpr</i> has changed, or when the text generated by <i>sourceCode</i> has changed, then this text is compiled as RHTML, built, encapsulated using <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>, and shown.</p>
<p>The demo component on this page uses <elm>RHTML</elm>, of course.</p>
<p>Here you have an <elm>RHTML</elm> within the demo component, i.e. an <elm>RHTML</elm> within an <elm>RHTML</elm>:</p>

<demo srctext=
'<define rvar=source
        value="1 + 1 = <b>\\{1+1\\}</b>"
></define>
<textarea @value="source.V" rows=3 cols=50></textarea>
<p>
<RHTML>\{source.V}</RHTML>
<p>
<RHTML #srctext="source.V"></RHTML>'></demo>

<h4>Caution</h4>
When you use <elm>RHTML</elm> on your site, you should be cautious of client-side (DOM-based) <a href="{wiki}Cross-site_scripting#Server-side_versus_DOM-based_vulnerabilities">cross-site scripting</a> (XSS, or code injection) attacks, when the text content can be entered by (or influenced by) the user, as on this site.
<br>Client-side XSS is much less dangerous than server-side XSS, but still: don't ever use <elm>RHTML</elm> on sites with any security impact.

<h3 id="RHTML-demo">Demo HTML vs RHTML</h3>
In the following demo you can enter a piece of (R)HTML and compare how it is parsed and rendered by the browser before and after OtoReact processing.
<br>Note how OtoReact removes irrelevant white space.

<demo #srcText=demoRendering></demo>


<h2 id=RHEAD><{}RHEAD>*</h2>
Any child elements of <elm class=sourcecode>RHEAD</elm> are inserted into the current document header, and are updated or removed as needed.
<p>
    You can use this e.g. to set a dynamic document title or to add dynamic links, or to specify header content for documents created by <elm>DOCUMENT</elm>.
</p>


<h2 id=DOCUMENT><{}DOCUMENT>*</h2>
<pre class=sourcecode>
    <{}DOCUMENT name=<i>docName</i> params?="<i>parameterNames</i>" window?=<i>windowVar</i> encapsulate?>
        <i>content</i>
    <{}/DOCUMENT>
</pre>
allows you to define a separate document or form, that remains part of the same RHTML application.
<br>
<i>content</i> can be any RHTML code, which is not rendered immediately, but <i>docName</i> is defined as a local variable, bound to an object with the methods listed below, that will create a window either to be shown or printed.
<br>
Any scripts within <i>content</i> are executed within the same browsing context as the main document, and local RHTML variables from the main document are visible in local scripts within <i>content</i>.
<p>
    When <code class=sourcecode>params</code> is specified, then the given parameter names are available within <i>content</i> as local variables.
</p>
<p>
    When <code class=sourcecode>window=<i>windowVar</i></code> is specified, then the given <i>windowVar</i> is available within <i>content</i> as a local variable, and will be bound to the created window.
    <br>When <code>window</code> is specified without value, then <i>windowVar</i> is assumed to be "<code>window</code>", hiding the global variable <code>window</code> that  refers to the main application window.
</p>
<p>
    When <code class=sourcecode>encapsulate</code> is specified, then the documentcreated by the methods below will be styled independent of the main document.
    <br>When not specified then all style sheets attached to the parent document are copied to the new document. (They won't be updated though.)
</p>
<p>
    Any <elm>style</elm> sheets within the <elm>DOCUMENT</elm> content are excluded from the parent document, and attached to each new child window.
</p>
<p>
    The available methods are:
</p>
<dl>
    <dt><code><i>docName</i>.open(<i>target?</i>, <i>windowFeatures?</i>, ...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in a separate browser window, using the optionally specified <i>target</i> and <i>windowFeatures</i> as in <a href="{MDN}Web/API/Window/open"><code>Window.open()</code></a>, and parameter names bound to the given <i>args</i>.
        <br>The window gets an <code>onkeydown</code> handler that closes the window when the escape key is pressed.
        <br>The method returns a reference to the opened window.
        <br>All windows opened through this method are automatically closed when the user leaves the current RHTML application (through the <a href="{MDN}Web/API/Window/pagehide_event">pagehide event</a>).
    </dd>
    <dt><code><i>docName</i>.print(...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in an invisible browser window with parameter names bound to the given <i>args</i>, and its browser print dialog is opened.
        <br>After the user has closed the print dialog, the invisible window is closed as well.
    </dd>
    <dt><code><i>docName</i>.closeAll()</code></dt>
    <dd>
        This closes all child windows opened through <code><i>docName</i>.open</code>.
        <p>
            You could for example use this in an <code>ondestroy</code> handler, to close all child windows when the document definition is removed from the DOM-tree: <pre #innerHTML='ColorCode(`<document name=docName ondestroy="docName.closeAll()">`)'></pre>
        </p>
    </dd>
</dl>

<demo #srctext=sampleDocument></demo>
