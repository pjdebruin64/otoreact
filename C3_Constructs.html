<h1>RHTML Construct Details</h1>

N.B. All construct attributes which must be JavaScript expressions, like <code>cond</code> and <code>of</code>, may optionally be prefixed with a hash mark: <code>#cond</code>, <code>#of</code>.
<br>Their meaning remains the same.

<h2 id=define>&lt;DEFINE var #value&gt;, Local Variables</h2>
<pre class=sourcecode>
<elm>DEFINE var=<i>name</i> #value="<i>expression</i>"</elm><elm>/DEFINE</elm>
</pre>
<p>
    introduces a local <u>immutable</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>Alternatively, one can give an interpolated string: <code>value="<i>string</i>"</code>.
    So for an expression, the '<code>#</code>' is required.
    <br>The variable is visible in all local expressions from the <elm>/DEFINE</elm> till the end of the enclosing element, except when obscured by nested definitions.
    <br>It cannot be assigned to, but when its value is an RVAR or some other object, then one can of course modify its properties.
</p>
<p>
    The expression is, by default, evaluated only once, when the respective DOM-trunk is built, not when it is updated.
    <br>When you add an attribute <code>react</code> (without value), then the expression is re-evaluated at every update.
</p>
<pre class=sourcecode><elm>DEFINE rvar=<i>name</i> #value="<i>expression</i>"</elm><elm>/DEFINE</elm></pre>
<p>
    introduces a local <u>reactive</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>This is equivalent to <code><elm>DEFINE var=<i>name</i> #value="RVAR(null, <i>expression</i>)"</elm><elm>/DEFINE</elm></code>.
</p>
<p>
    <elm>DEFINE</elm> may be abbreviated to <elm>DEF</elm>.
</p>
<p>
    Local variable names (including loop variables and component parameters) obey strict <a href="{wiki}Scope_(computer_science)#Lexical_scope">lexical scoping</a> rules:
</p>
<demo content=
"<def var=a #value=&quot;10&quot;></def>
<def var=f #value=&quot;(x) => a+x&quot;></def>

<p> \{a}, \{f(1)} </p>

<p>
    <def var=a #value=20></def>
    \{a}, \{f(2)}
</p>

<p> \{a} </p>"
></demo>

<h2>&lt;IF cond&gt; &lt;ELSE&gt;</h2>
<pre class=sourcecode><{}IF cond="<i>expr</i>">
    <i>ThenPart</i>&nbsp; 
    <{}ELSE<i>?</i>> <i>ElsePart</i> <{}/ELSE>
<{}/IF>
</pre> is a conditional trunk of RHTML.
<ul>
    <li>
        <code><i>ThenPart</i></code> may be any piece of RHTML, which is included in the document IF the value of <code><i>expr</i></code> is true (or <a href="{MDN}Glossary/Truthy">truthy</a>).
    </li>
    <li>
        ELSE, when there is an <elm>ELSE</elm> part (the question mark indicates it is optional), then <code><i>ElsePart</i></code> is included. 
    </li>
</ul>

<h2>&lt;CASE&gt; &lt;WHEN cond&gt; &lt;ELSE&gt;</h2>
<pre class=sourcecode>
&lt;CASE&gt;
    &lt;WHEN cond="<i>expr</i>"&gt; <i>WhenPart</i> &lt;/WHEN&gt;
    &hellip;
    &lt;ELSE<i>?</i>&gt; <i>ElsePart</i> &lt;/ELSE&gt;
&lt;/CASE&gt;
</pre>
<ul>
    <li>
        There may be multiple <elm>WHEN</elm> parts.
    </li>
    <li>
        The first <i>WhenPart</i> for which the value of <i>expr</i> is truthy, is included in the document.
    </li>
    <li>
        If none is truthy, and there is an <elm>ELSE</elm> part, then <i>ElsePart</i> is included.
    </li>
</ul>

<h2>&lt;FOR let of index?&gt;</h2>
<pre class="sourcecode">
&lt;FOR let=<i>name</i> of="<i>iterableExpression</i>"&gt;
    <i>BodyPart</i>{}
&lt;/FOR&gt;
</pre>
<p>
    The normal FOR-construct repeats its <i>BodyPart</i> for each item yielded by the value of <i>iterableExpression</i>.
    <br>(There is also a variant FOR-construct without attribute <code>let</code>, which <a href="#FORoverSlots">iterates over component slots</a>.)
</p>
<p>
    The value of <i>iterableExpression</i> must be an <a href="{MDN}Web/JavaScript/Reference/Statements/for...of">iterable object</a>, e.g. an Array, or the result of the RHTML <a href="#rangeFunction">range function</a>, if you want a numeric repetition. 
</p>
<p>
    Attribute <code>let=<i>name</i></code> is compulsory, but <i>name</i> may be missing or empty. When nonempty, <i>name</i> becomes a local (immutable) variable bound to the respective item.
</p>

<demo #content="sampleParticipants">
</demo>

Further on, <elm>FOR</elm> can have the following attributes:
<dl>
    <dt><code>index=<i>indexName</i></code></dt>
    <dd>
        When present, <i>indexName</i> becomes a local variable bound to the zero-based index number: 0 for the first item, 1 for the second, and so on.
        <br>When <code>index</code> is present but <i>indexName</i> omitted, then <code>index='index'</code> is assumed.
    </dd>

    <dt><code>previous=<i>prevName</i></code></dt>
    <dd>
        When present, <i>prevName</i> becomes a local variable bound to the <i>preceeding</i> item in the iteration, or <code>null</code> for the first item.
        <br>This allows one to easily check for changing properties within the iteration.
        <br>When <i>prevName</i> is omitted, then <code>'previous'</code> is assumed.
    </dd>

    <dt><code>key="<i>keyExpression</i>"</code></dt>
    <dd>
        When a FOR-construct has to be updated, items in the iteration may have been removed, added, reordered, or replaced.
        <br>OtoReact does not make any assumption about these items; it will by default completely rebuild the FOR DOM-tree on every update.
        <p>
            You may however specify a <i>keyExpression</i>, which may refer to <i>name</i> and <i>indexName</i> and should compute a unique "key" value for each item in the iteration.
            <br>In that case OtoReact will use this to identify old and new items. When an item in a new iteration has the same key value as an item in the previous iteration, then OtoReact won't rebuild its DOM-tree, but will move its previous DOM-tree to its (possibly) new position and will update it in-place.
            <br>This has the following effects:
        </p>
        <ul>
            <li>It is faster</li>
            <li>If any input element in the tree had received focus or inputdata, then it will keep that focus or data</li>
            <li>Any <code>oncreate</code> handlers won be executed again</li>
            <li>If the RHTML in <i>BodyPart</i> created any RVAR's or other objects, then these won't be renewed but will keep their previous value</li>
        </ul>
        <p>
            When items in the iteration are always distinct, then the key may be the item itself: <code>key=<i>name</i></code>.
            <br>When items in the iteration always remain in place, then the key may be the index number: <code>key=<i>indexName</i></code>
        </p>
    </dd>

    <dt><code>hash="<i>hashExpression</i>"</code></dt>
    <dd>
        Processing can be further speeded up by specifying a <i>hashExpression</i>.
        <br>OtoReact cannot quickly detect whether some property (deep) inside an object has changed, so it will by default update all subtrees when updating the FOR-construct, meaning it will recompute all properties, conditions, et cetera.
        <p>
            If, however, you specify a <i>hashExpression</i>, then OtoReact will assume an item (identified by its key) has not changed when the value of <i>hashExpression</i> hasn't changed, and it won't spend time on updating its DOM subtree.
        </p>
        <p>
            The hash expression need not be a real <a href="{wiki}Hash_function">hash function</a>; it could be a possibly long string.
            <br>If, e.g., items are read from an external source and parsed using <code>JSON.parse</code>, then one could preserve the unparsed string and use it as the hash value.
        </p>
    </dd>

    <dt><code>reactive</code></dt>
    <dd>
        The loop variable <i>name</i> is immutable, but events may modify its properties. If you need the DOM subtree to react on property changes, then you can add attribute <code>reactive</code> to make <i>name</i> reactive.
        <p>
            When <code>reactive</code> is present, then <i>name</i> gets a property <code><i>name</i>.U</code>, which yields the value of <i>name</i> and marks it as dirty, just as with <a href="#ReactiveVariables">reactive variables</a>.
            <br><i>Name</i> does not become a full RVAR: one cannot get or set <code><i>name</i>.V</code>. One could call it an RVAR-light.
        </p>
        <p>
            Note that just <i>name</i> is marked dirty, not the source (array) of the iteration. If you need elements of your application <i>outside</i> the local subtree to react on changes, then you can use the <code>updates</code> attribute describe below.
        </p>
    </dd>
    <dt><code>updates="<i>rvarList</i>"</code></dt>
    <dd>
        If you want changes to properties of <i>name</i> to have reactions outside the local subtree, then you can use <code>updates="<i>rvarList</i>"</code>.
        <br><i>rvarList</i> must be a comma-separated list of zero or more RVAR's.
        <p>
            When present, then <i>name</i> becomes reactive as above, and whenever <i>name</i> is marked dirty (by a reference to ), the all RVAR's in the list will be marked dirty too.
        </p>
        <p>You can find an example of this in the todo-list below: whenever an item is (un)marked as done, then both lists that depend on <code>TODO</code> are updated.</p>
    </dd>
</dl>

<h2 id=Scripts>&lt;SCRIPT&gt;</h2>
<p>
    Scripts can be included almost anywhere in your application, either embedded or through an external <code>src</code> reference.
</p>
<p>
    You have to be aware that scripts included in the main document, except those tagged with <code>nomodule</code>, are automatically executed by the browser before OtoReact has had any opportunity to intervene.
</p>
<p>
    You have also to be aware that scripts in browser-based JavaScript come in two flavours: <i>classic</i> JavaScript and JavaScript <i>modules</i>, and that OtoReact is imported as a JavaScript module.
</p>
<dl>
    <dt><elm>SCRIPT src?</elm> in main file</dt>
    <dd>
        Scripts in the main document file with just <elm>SCRIPT</elm> are treated as <u>classic</u> JavaScript.
        <br>That means that they will be executed as soon as they are parsed, and that is <i>before</i> OtoReact has been loaded.
        <br>So they cannot execute OtoReact functions like <code>RVAR</code>, until OtoReact has been loaded.
        <br>On the other hand, names defined in a classic script are automatically put in the global environment and are available in RHTML code.
    </dd>

    <dt><elm>SCRIPT type=module src?</elm> in main file</dt>
    <dd>
        Scripts in the main document file with <code>type=module</code> are treated as a JavaScript <u>module</u>.
        <br>That means that it will be executed after the whole document has been parsed and, assuming that you call OtoReact at the top of your document, <i>after</i> OtoReact has been loaded and has compiled your document, but before the document has been built.
        <br>So one can immediately call OtoReact functions like <code>RVAR</code>.
        <br>On the other hand, names defined in a JavaScript module are not automatically put in the global environment. You have to explicitly define them as properties of the global object: <code class=sourcecode>window.<i>name</i> = &hellip;</code> or <a href="{MDN}Web/JavaScript/Reference/Global_Objects/globalThis" title="What is globalThis?">better</a>: <code class=sourcecode>globalThis.<i>name</i> = &hellip;</code> before they are available in RHTML code.
    </dd>

    <dt>
        <elm>SCRIPT nomodule src?</elm> anywhere
        <br><elm>SCRIPT src?</elm> in included files or inside <{}RHTML>
    </dt>
    <dd>
        Scripts included through <elm>INCLUDE</elm> or <elm>IMPORT</elm>, with a <code>nomodule</code> attribute, or inside <elm>RHTML</elm> dynamic code like the code demo's in this document, work still different.
        <br>These are not encountered and executed by the browser at all. Instead, they are executed in <a href="{MDN}Web/JavaScript/Reference/Strict_mode">strict mode</a> by OtoReact during compilation.
        <br>That means that OtoReact functions are available, names are not automatically global, but module functionality like <code>import</code> is not available, not even when you add <code>type=module</code>.
        <p>
            In this case, OtoReact will also look for an attribute <code class=sourcecode>defines="<i>nameList</i>"</code>, specifying a comma-separated list of names defined inside the script.
            <br>OtoReact will make these names available to your RHTML code.
            <br>(Currently as global names, later on as local variables.)
        </p>
    </dd>
    <dd>
        If you don't want the distinction between scripts in the main file and scripts in included files, <b>you can always use <elm>SCRIPT nomodule</elm></b>.
        <br>These are always skipped by the browser, and always executed by OtoReact.
    </dd>
</dl>

<p>
    To waylay hackers of this website, JavaScript names <code>fetch</code>, <code>XMLHttpRequest</code>, and <code>import</code> are not available in scripts within the editable demo's on this page.
    <br><code>eval</code> is redefined to access the global environment only.
</p>

<h2>&lt;COMPONENT&gt; ...</h2>
<demo #content=sampleTODO>
</demo>

<p>Components may be recursive, i.e. refer to themselve.
<br>Here is a recursive component, imaging nested lists of lists:</p>
<demo #bShow=false #content=sampleRecursion></demo>

<p>Components may redefine HTML constructs. To refer to the original construct, add a dot to the tag name.
<br>Here is a component that redefines <elm>a</elm> to ensures that all links with no target and an external href, get a <code>target='_blank'</code> attribute:</p>
<demo #content=sampleRedefineA>
</demo>


<h2>&lt;REACT on&gt;, reacton ...</h2>
<div id=TicTacToe></div>
<demo #bShow=false #content=sampleTicTacToe></demo>


<h2 id=FORoverSlots>&lt;FOR #of&gt; component slots ...

</h2>
Here is a component which allows one to define tables column by column.
<demo #bShow=false #content=sampleTableMaker></demo>

<h2>&lt;INCLUDE src&gt;</h2>
<elm>INCLUDE src="<i>URL</i>"</elm> allows you to include another RHTML file as if it were inserted into the main file.
<br>The file is fetched and compiled <i>asynchronously</i>: compiling the main file will continue while the file is being fetched.

<p>
    To speed things up, you can insert a <code>preload</code> link in the document header:
</p>
<pre>    
    <{}link rel=preload href="<i>URL</i>" as=fetch crossorigin>
</pre>
("<code>crossorigin</code>" seems incorrect, but Google Chrome requires it.)

<h2>&lt;IMPORT src&gt; ...</h2>

<h2>&lt;RHTML&gt; ...</h2>

<h2>&lt;DOCUMENT&gt; ...</h2>