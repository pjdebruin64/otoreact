<h1>RHTML Constructs</h1>

N.B. All construct attributes which must be JavaScript expressions, like <code>cond</code> and <code>of</code>, may optionally be prefixed with a hash mark: <code>#cond</code>, <code>#of</code>.
<br>Their meaning remains the same.

<p>
    Any attribute starting with an underscore "_" is ignored. So one can use this to insert a comment right between attributes (<code>_="Some comment"</code>) or to comment out some attribute.
</p>

<p>
    Otherwise, it is an error when a construct instance has unknown attributes.
</p>

<h2 id=define><{}DEFINE var #value>, Local Variables</h2>
<pre class=sourcecode>
<elm>DEFINE var=<i>name</i> #value="<i>expression</i>"</elm><elm>/DEFINE</elm>
</pre>
<p>
    introduces a local <u>immutable</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>Alternatively, one can give an interpolated string: <code>value="<i>string</i>"</code>.
    So for an expression, the '<code>#</code>' is required.
    <br>The variable is visible in all local expressions from the <elm>DEFINE</elm> till the end of the enclosing element, except when obscured by nested definitions.
    <br>It cannot be assigned to, but when its value is an RVAR or some other object, then one can of course modify its properties.
</p>
<p>
    The expression is, by default, evaluated only once, when the respective DOM-trunk is built, not when it is updated.
</p>
<p>When you add an attribute <code class=sourcecode>updating</code> or <code class=sourcecode>reacting</code> (without value), then the expression is re-evaluated at every update.</p>
<pre class=sourcecode><elm>DEFINE rvar=<i>name</i> #value?="<i>expression</i>" store?=<i>storage</i> async?</elm><elm>/DEFINE</elm></pre>
<p>
    introduces a local <u>reactive</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>This is equivalent to <code><elm>DEFINE var=<i>name</i> #value="RVAR(null, <i>expression</i>, <i>storage</i>)"</elm><elm>/DEFINE</elm></code>.
    <br>When <code class=sourcecode>store</code> is specified, then the rvar value is stored in the given storage, see <a href=#Persistence>Persistence</a>.
</p>
<p>
    When <code class=sourcecode>async</code> is specified, then <i>expression</i> must yield a <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
    The value of the rvar wil initially be <code>undefined</code>, and when the promise resolves to a value, then the rvar will be set to that value.
</p>
<p><elm>DEFINE</elm> may not have any child nodes, other than comments or white space.</p>
<p>
    <elm>DEFINE</elm> may be abbreviated to <elm class=sourcecode>DEF</elm>.
</p>
<p id=lexicalScoping>
    Local variable names (including loop variables and component parameters) obey strict <a href="{wiki}Scope_(computer_science)#Lexical_scope">lexical scoping</a> rules:
</p>
<demo #srctext=demoScoping></demo>

<h2 id=Case><{}CASE> <{}WHEN cond> <{}ELSE></h2>
<pre class=sourcecode>
<{}CASE hiding?>
    <{}WHEN cond="<i>expr</i>"> <i>WhenPart</i> <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre> is a conditional piece of RHTML.
<ul>
    <li>
        There may be multiple <elm>WHEN</elm> parts.
    </li>
    <li>
        The first <i>WhenPart</i> for which the value of <i>expr</i> is true (or <a href="{MDN}Glossary/Truthy">truthy</a>), is included in the document.
    </li>
    <li>
        If none is truthy, and there is an <elm>ELSE</elm> part, then <i>ElsePart</i> is included.
    </li>
    <li>
        When <code class=sourcecode>hiding</code> is specified, then <i>all</i> alternatives will be included in the DOM tree, but the unwanted ones will be <a href="{MDN}HTML/Global_attributes/hidden">hidden</a>.
        <br>This may result in slower initial building, but faster switching between alternatives (especially when using <a href="#thisreactson"><code>thisreactson</code></a>).
    </li>
</ul>
<h3 id=PatternMatching>Pattern Matching</h3>
Furthermore, <elm>CASE</elm> can select an alternative based on <i>pattern matching</i> against a given string value.
<p>Substrings of the value can be captured into new local variables.
<p>There are three variants of patterns:
</p>
<pre class="sourcecode">
<{}CASE #value="<i>expr</i>">
    <{}WHEN match="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN urlmatch="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN regmatch="<i>regExp</i>" captures?="<i>nameList</i>"> &hellip; <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
All three variants are case-insensitive, and all can be combined with a simple condition <code>cond</code>.
<dl>
    <dt><code>match="<i>pattern</i>"</code></dt>
    <dd>
        The value is matched against the given simple pattern, which may contain the following wildcards:
        <ul>
            <li><code>?</code> matches any single character</li>
            <li><code>*</code> matches any string of characters</li>
            <li><code>[<i>charString</i>]</code> matches any character in <i>charString</i>, where all <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">rules for JavaScript character classes</a> apply</li>
            <li>
                <code>\{ <i>varName</i> \}</code> matches non-greedily any string of characters, and 
                <ul><li>
                    The matched string will be captured in <a href=#Variables>local variable</a> <i>varName</i>
                </li></ul>
            </li>
            <li><code>\</code> followed by any character matches just that character</li>
        </ul>
        The whole value has to match, not just a substring.
    </dd>
    <dt><code>urlmatch="<i>pattern</i>"</code></dt>
    <dd>
        This form is meant to be matched against (parts of) an URL, and is useful for routing.
        <br>The recognized patterns are the same simple patterns as above, but any substring captured in a local variable will be <a href="{wiki}Percent-encoding">URL-decoded</a>.
    </dd>

    <dt><code>regmatch="<i>regExp</i>" captures?="<i>nameList</i>"</code></dt>
    <dd>
        <i>regExp</i> can be any JavaScript <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Cheatsheet">regular expression pattern</a>.
        <p>The match succeeds when any substring of the string value matches against <i>regExp</i>.</p>
        <p>When <code>captures="<i>nameList</i>"</code> is specified, then the values captured by any <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">capturing groups</a> in the pattern will be stored in local variables with the specified names, in order of appearance. Use empty names to skip unneeded capturing groups.</p>
    </dd>
</dl>
Patterns with captures cannot be combined with <code>hiding</code>, as no DOM-tree can be built when the variable values are unknown.


<h2 id=If><{}IF cond> <{}THEN> <{}ELSE></h2>
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <i>ThenPart</i>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
or
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <{}THEN> <i>ThenPart</i> <{}/THEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
is the same as:
<pre>
<{}CASE>
    <{}WHEN cond="<i>expr</i>"> <i>ThenPart</i> <{}/WHEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
<p>
    All hiding and pattern-matching features of <elm>CASE</elm><elm>WHEN</elm> apply to <elm>IF</elm> as well.
</p>


<h2 id=For><{}FOR let of index?></h2>
<pre class="sourcecode">
<{}FOR let=<i>name</i> of="<i>iterableExpression</i>">
    <i>BodyPart</i>
<{}/FOR>
</pre>
<p>
    The normal FOR-construct repeats its <i>BodyPart</i> for each item yielded by the value of <i>iterableExpression</i>.
</p>
<p>
    The value of <i>iterableExpression</i> must be an <a href="{MDN}Web/JavaScript/Reference/Statements/for...of">iterable object</a>, e.g. an Array, or the result of the RHTML <a href="#rangeFunction">range function</a>, if you want a numeric repetition. 
</p>
<p>
    Attribute <code>let=<i>name</i></code> (or <code>var=<i>name</i></code>) is compulsory, but <i>name</i> may be missing or empty. When nonempty, <i>name</i> becomes a local (immutable) variable bound to the respective item.
</p>

<demo #srctext="sampleParticipants">
</demo>

Further on, <elm>FOR</elm> can have the following attributes:
<dl>
    <dt><code>index=<i>indexName</i></code></dt>
    <dd>
        When present, <i>indexName</i> becomes a local variable bound to the zero-based index number: 0 for the first item, 1 for the second, and so on.
        <br>When <code>index</code> is present but <i>indexName</i> omitted, then <code>index='index'</code> is assumed.
    </dd>

    <dt><code>previous=<i>prevName</i></code></dt>
    <dd>
        When present, <i>prevName</i> becomes a local variable bound to the <i>preceeding</i> item in the iteration, or <code>undefined</code> for the first item.
        <br>This allows one to easily check for changed properties within the iteration.
        <br>When <i>prevName</i> is omitted, then <code>'previous'</code> is assumed.
    </dd>
    
    <dt><code>next=<i>nextName</i></code></dt>
    <dd>
        In the same way, <i>nextName</i> becomes bound to the <i>next</i> item in the iteration.
    </dd>

    <dt><code>key="<i>keyExpression</i>"</code></dt>
    <dd>
        When a FOR-construct has to be updated, items in the iteration may have been removed, added, reordered, or replaced.
        <br>OtoReact does not make any assumption about these items; it will by default completely rebuild the FOR DOM-tree on every update.
        <p>
            You may however specify a <i>keyExpression</i>, which may refer to <i>name</i> and <i>indexName</i> and should compute a unique "key" value for each item in the iteration.
            <br>In that case OtoReact will use this to identify old and new items. When an item in a new iteration has the same key value as an item in the previous iteration, then OtoReact won't rebuild its DOM-tree, but will move its previous DOM-tree to its (possibly) new position and will update it in-place.
            <br>This has the following effects:
        </p>
        <ul>
            <li>It is faster</li>
            <li>If any input element in the tree had received focus or inputdata, then it will keep that focus or data</li>
            <li>Any <code>oncreate</code> handlers won be executed again</li>
            <li>If the RHTML in <i>BodyPart</i> created any RVAR's or other objects, then these won't be renewed but will keep their previous value</li>
        </ul>
        <p>
            When items in the iteration are always distinct, then the key may be the item itself: <code>key=<i>name</i></code>.
            <br>When items in the iteration always remain in place, then the key may be the index number: <code>key=<i>indexName</i></code>
        </p>
    </dd>

    <dt><code>hash="<i>hashExpressionList</i>"</code></dt>
    <dd>
        Processing can be further speeded up by specifying one or more comma-separated "hash expressions".
        <br>OtoReact cannot quickly detect whether some property (deep) inside an object has changed, so it will by default update all subtrees when updating the FOR-construct, meaning it will recompute all properties, conditions, et cetera.
        <p>
            If, however, you specify a <i>hashExpressionList</i>, then OtoReact will assume an item (identified by its key) has not changed when the values of the expressions in <i>hashExpressionList</i> haven't changed, and it won't spend time on updating its DOM subtree.
        </p>
        <p>
            The hash expression need not be a real <a href="{wiki}Hash_function">hash function</a>; it could be a possibly long string.
            <br>If, e.g., items are read from an external source and parsed using <code>JSON.parse</code>, then one could preserve the unparsed string and use it as the hash value.
        </p>
    </dd>

    <dt><code>reacting</code> (or <code>reactive</code>)</dt>
    <dd>
        The loop variable <i>name</i> is immutable, but events may modify its properties. If you need the DOM subtree to react on property changes, then you can add attribute <code>reacting</code> (or <code>reactive</code>) to make <i>name</i> reactive.
        <p>
            When <code>reacting</code> is present, then <i>name</i> gets a property <code><i>name</i>.U</code>, which yields the value of <i>name</i> and marks it as dirty, just as with <a href="#RVAR">reactive variables</a>.
            <br><i>Name</i> does not become a full RVAR: one cannot get or set <code><i>name</i>.V</code>. One could call it an RVAR-light.
        </p>
        <p>
            Note that just <i>name</i> is marked dirty, not the source (array) of the iteration. If you need elements of your application <i>outside</i> the local subtree to react on changes, then you can use the <code>updates</code> attribute described below.
        </p>
    </dd>
    <dt><code>updates="<i>rvarList</i>"</code></dt>
    <dd>
        If you want changes to properties of <i>name</i> to have reactions outside the local subtree, then you can use <code>updates="<i>rvarList</i>"</code>.
        <br><i>rvarList</i> must be a comma-separated list of zero or more RVAR's.
        <p>
            When present, then <i>name</i> becomes reacting as above, and whenever <i>name</i> is marked dirty (by a reference to <code><i>name</i>.U</code>), then all RVAR's in <i>rvarList</i>> will be marked dirty too.
        </p>
        <p>You can find an example of this in the todo-list below: whenever an item is (un)marked as done, then both lists that depend on <code>TODO</code> are updated.</p>
    </dd>
</dl>

<h2 id=Scripts><{}SCRIPT defines?></h2>
<p>
    Scripts can be included almost anywhere in your application, either embedded or through an external <code>src</code> reference.
</p>
<p>
    External scripts may be written in <a href="https://www.typescriptlang.org/">TypeScript</a>, of course.
</p>
<p>
    You have to be aware that scripts included in the main document, except those tagged with <code>nomodule</code>, are automatically executed by the browser before OtoReact has had any opportunity to intervene.
</p>
<p>
    You have also to be aware that scripts in browser-based JavaScript come in two flavours: <i>classic</i> JavaScript and JavaScript <i>modules</i>, and that OtoReact is imported as a JavaScript module.
</p>
<p>This gives you the followingalternatives.</p>
<dl>
    <dt><elm>SCRIPT src?</elm> in main file:</dt>
    <dd>
        Scripts in the main document file with just <elm>SCRIPT</elm> are treated as <u>classic</u> JavaScript.
        <br>That means that they will be executed as soon as they are parsed, and that is <i>before</i> OtoReact has been loaded.
        <br>So they cannot execute OtoReact functions like <code>RVAR</code>, until OtoReact has been loaded.
        <br>Names defined in a classic script are automatically put in the global environment and are available in RHTML code.
    </dd>

    <dt><elm>SCRIPT type=module src?</elm> in main file:</dt>
    <dd>
        Scripts in the main document file with <code>type=module</code> are treated as a JavaScript <u>module</u>.
        <br>That means that it will be executed after the whole document has been parsed and, assuming that you call OtoReact at the top of your document, <i>after</i> OtoReact has been loaded and has compiled your document, but before the document has been built.
        <br>So one can immediately call OtoReact functions like <code>RVAR</code>.
        <br>Names defined in a JavaScript module are not automatically put in the global environment. You have to explicitly define them as properties of the global object: <code class=sourcecode>window.<i>name</i> = &hellip;</code> or <a href="{MDN}Web/JavaScript/Reference/Global_Objects/globalThis" title="What is globalThis?">better</a>: <code class=sourcecode>globalThis.<i>name</i> = &hellip;</code> before they are available in RHTML code.
    </dd>

    <dt>
        <elm>SCRIPT [type=module] nomodule src? defines?</elm> anywhere;
        <br>Any <elm>SCRIPT ... </elm> in included files or inside <{}RHTML>:
    </dt>
    <dd>
        Scripts with a <code>nomodule</code> attribute, or included through <elm>INCLUDE</elm> or <elm>IMPORT</elm>, or inside <elm>RHTML</elm> dynamic code like the code demo's in this document, work still different.
        <br>These are not encountered and executed by the browser at all. Instead, they are executed by OtoReact during or after compilation:
        <ul>
            <li>OtoReact functions are available</li>
            <li>The script may be external (with <code>src</code>) or internal</li>
            <li>
                The script may be classic or module.
                <br>For classic scripts:
                <ul>
                    <li>OtoReact modifies the script so that defined names are <b>not automatically global</b></li>
                    <li>OtoReact executes the script once <b>in <a href="{MDN}Web/JavaScript/Reference/Strict_mode">strict mode</a></b> during compilation</li>
                </ul>
                For module scripts:
                <ul>
                    <li>Names are never automatically global</li>
                    <li>Otoreact executes the script asynchronously while compiling, and awaits the results when building</li>
                </ul>
            </li>
            <li>
                When there is an attribute <code class=sourcecode>defines="<i>nameList</i>"</code>, specifying a comma-separated list of names defined inside the script, then OtoReact makes these names available <i>as local variables</i> in the RHTML code following the <elm>SCRIPT</elm> element.
                <br>This works for both classic and module, internal and external scripts.
                <p>
                    For module scripts, the names must be marked as exports inside the script.
                </p>
            </li>
        </ul>
    </dd>
    <dd>
        If you don't want the distinction between scripts in the main file and scripts in included files, <b>you can always use <code>nomodule</code></b>.
        <br>These are always skipped by the browser, and always executed by OtoReact.
    </dd>
</dl>

<h2 id=React><{}REACT on? hash? renew?></h2>
<pre class=sourcecode>
<elm>REACT on=<i>RVARlist</i></elm>
    <i>Content</i>
<elm>/REACT</elm></pre>
specifies that the given content should <i>react on</i> changes to any of the listed RVAR's. So whenever one or more of the RVAR's have changed, the content will be updated.

<p>
    With attribute <elm class=sourcecode>hash="<i>expressionlist</i>"</elm>, the given content will <i>only</i> be updated when an update is requested <i>and</i> the value of some expression(s) in the list has changed. This can improve performance.
</p>

<p>
    With attribute <code class=sourcecode>renew</code>, the given content will never be updated, but will be removed and rebuilt on every update request.
</p>
<p>
    An <elm>REACT</elm> element without content will not produce any DOM elements, and can be useful to insert <code>oncreate</code> or <code>onupdate</code> handlers in between elements.
</p>

<h2 id=reacton>reacton, thisreactson</h2>
One can add RHTML attribute <code class=sourcecode>reacton="<i>RVARlist</i>"</code>, or <code>reactson="<i>RVARlist</i>"</code>, to any source element or construct. This is the same as including the element within <elm>REACT on=<i>RVARlist</i></elm>.
<p id=thisreactson>
    RHTML attribute <code class=sourcecode>thisreactson="<i>RVARlist</i>"</code> specifies that only properties of the element or construct itself, but <i>not its children</i>, should react on changes to the RVARs. This is faster of course.
</p>

<div id=TicTacToe></div>
<demo #bShow=false #srctext=sampleTicTacToe></demo>

<h2 id=Component><{}COMPONENT encapsulate?></h2>
<p>
<elm>COMPONENT</elm> defines a new user-defined construct, or custom element.
<br>A component definition consists of a component <i>signature</i>, optionally one or more style sheets, scripts and local definitions, and a component <i>template</i>:
<pre class=sourcecode>
<{}COMPONENT encapsulate?>

  <{}SIGNATURE> <i>Signature</i> <{}/SIGNATURE>
  <comm>or just:</comm>
  <i>Signature</i>

  <{}STYLE &hellip;> &hellip; <{}/STYLE>&hellip;
  <{}SCRIPT &hellip;> &hellip; <{}/SCRIPT>&hellip;
  <{}DEFINE &hellip;> &hellip; <{}/DEFINE>&hellip;

  <{}TEMPLATE &hellip;> <i>Template</i> <{}/TEMPLATE>
  
<{}/COMPONENT>
</pre>
<ul>
    <li>
        The <a href=#Signatures><i>signature</i></a> describes how invocations of the component (or construct), called '<i>instances</i>', look like. The signature may specify <i>parameters</i> and <i>slots</i>.</li>
    <li>
        The <a href=#Templates><i>template</i></a> describes what content should be generated for each component instance. Inside the template, parameters are available as JavaScript variables, and slots are available as RHTML constructs. So the template may contain instances of the slots.</li>
    <li>
        <a href=#Instances><i>Instances</i></a> may or must specify values for each parameter, and contain blocks of RHTML code (or actually <i>templates</i>) for each slot.
    </li>
    <li>
        A component may be <a href=#Encapsulate><i>encapsulated</i></a> or not. Encapsulated means mainly that the component contains its own styling rules, independent of the main document.
    </li>
    <li>
        Component templates can contain nested component definitions.
    </li>
    <li>
        Component templates can use local variables defined outside of the component.
        <br>So a nested component definition can use the parameter values of the outer component.
    </li>
</ul>
<h3 id=Signatures>Signatures</h3>
<p>
    The first element inside <elm>COMPONENT</elm> is its signature.
    <br>It is optionally surrounded by <elm>SIGNATURE</elm>.
    <br>E.g.:
    <pre #innerHTML="ColorCode(C1)"></pre>
    <ul>
        <li>
            The tag name of the signature element ('repeat' in this example) defines the name of the component.
        </li>
        <li>
            Attributes like <code><i>name</i></code>, <code>#<i>name</i></code>, or <code>@<i>name</i></code> of the signature element define the parameters of the component.
            <br>Instances of the component must have the same attributes, and these correspond to local variables inside the component template.
            <p>There are special cases:</p>
            <ul>
                <li>
                    Attributes with a question mark <code><i>name?</i></code> or with a nonempty default value <code><i>name</i>="<i>string</i>"</code> or <code><i>#name</i>="<i>expression</i>"</code> define <b>optional parameters</b>.
                    <br>When an instance doesn't have this attribute, then the specified default string or expression is used instead, or <code>undefined</code> when there is no default.
                    <p>
                        An empty <i>string</i>: <code><i>name</i>=""</code> is not recognized as a default value, because the HTML parser does not distinguish between a missing value and the empty string.
                        <br>To specify the empty string as default value, one must use an empty string <i>expression</i>: <code>#<i>name</i>=" '' "</code>.
                    </p>
                    <p>The default default value is <code>undefined</code>.</p>
                </li>
                <li>
                    Attributes <code><i>name</i></code> where <i>name</i> starts with "on" represent <b>event handlers</b>.
                    <br>Values are compiled as JavaScript, and the default default value is the empty handler.
                </li>
                <li>
                    Attributes <code>@<i>name</i></code> define <b>two-way parameters</b>.
                    <br>Their values must be valid <a href="#TwoWayBinding">assignment targets</a>.
                </li>
                <li>
                    An attribute prefixed with three dots <code>...<i>name</i></code> is a <b>rest parameter</b>. It must be the last parameter.
                    <br>All instance attributes that do not match a normal parameter are collected into this rest parameter, which can be passed on to an HTML element.
                </li>
            </ul>
        </li>
        <li>
            Each child element of the signature element defines a <i>slot</i> of the component.
            <br>These child elements are themselves signatures: slot signatures.
            <p>
                For each slot, component instances may have one or more child elements that should match the slot signature.
                <br>The slots are available <i>as constructs</i> within the component template.
            </p>
            <p>
                When building a component instance, the content of any instance child element that matches a slot becomes the (slot) template for the slot instances within the component template
            </p>
            <p>
                As slots have signatures, they can have parameters and slots themselves.
            </p>
        </li>
        <li>
            There is one special slot name, <elm>CONTENT</elm>. When a component signature contains a <elm>CONTENT</elm> slot, then all content of a component instance that does not match any other slot, forms a template for the <elm>CONTENT</elm> slot.
        </li>
    </ul>
</p>

<h3 id=Templates>Templates</h3>
The component template is tagged <elm>template</elm>. E.g.:
<pre #innerHTML="ColorCode(C2)"></pre>
<ul>
    <li>
        Parameters of the component (like <code>count</code>) are available as local variables inside the template.
    </li>
    <li>
        The value of the local variable <i>name</i> representing a two-way parameter <code>@<i>name</i></code> will be a new RVAR for each created instance of the component.
        <br>The RVAR value <code><i>name</i>.V</code> will be the value of the assignment target provided in the instance, and whenever a new value is assigned to the RVAR, that value will be assigned to the assignment target as well.
    </li>
    <li>
        Parameter names <u>may</u> be repeated in the template tag, like: <elm>template #count</elm>.
        <br>Or they may specify a local variable name, like: <elm>template #count=Count</elm>. This is useful when you want to have uppercase characters in the local variable name, because the parameter name itself, being an attribute name, is always seen as lowercase by the parser.
    </li>
    <li>Slots of the component (like <elm>rbody</elm>) are available as constructs inside  the template</li>
    <li>The template of a component with slots may contain <a href="#FORoverSlots">a special kind of FOR-loop</a> which iterates over the slot templates</li>
</ul>

<h3 id=Instances>Instances</h3>
A component is instantiated by a tag containing the component name:

<pre #innerHTML="ColorCode(C3)"></pre>

<h4>Parameter values</h4>
A component instance may/must have attributes that provide values for all optional/compulsory parameters of the template. There are four forms:
<ul>
    <li>By default, the value is specified as an interpolated string: <code><i>name</i>="<i>string</i>"</code></li>
    <li>When the name is prefixed with a hash mark, the value is computed as a JavaScript expression: <code>#<i>name</i>="<i>expression</i>"</code></li>
    <li>
        When <i>name</i> starts with "on", then the value is specified as a block of JavaScript statements, just like an event handler: <code><i>name</i>="<i>statements</i>"</code>
        <br>The value of the parameter will be the routine <code>function(event) \{ <i>statements</i> \}</code>.
    </li>
    <li>
        The value provided for a two-way parameter <code>@<i>name</i></code> must be a valid <a href="#TwoWayBinding">assignment target</a>.
    </li>
    <li>
        As with standard constructs, attribute names starting with an underscore "_" are ignored.
    </li>
</ul>
<p>
    When the component has a rest parameter, then the values specified by any remaining attributes are collected into that rest parameter. Otherwise it is an error when there are remaining attributes.
</p>

<h4>Slot templates</h4>
The component instance may contain templates for each of the slots of the component. So just as the component definition contains a component template that can be instantiated by a client, so the component instances may contain slot templates that can be instantiated within the component template.
<ul>
    <li>
        Slot templates are tagged by the slot name (not by <elm>template</elm>)
    </li>
    <li>
        Slot templates must be immediate children of the component instance. They are fixed at compile time, so they cannot be inside a <elm>CASE</elm> or some other construct.
    </li>
    <li>
        When the slot signature contains parameters, then these names <u>must</u> be repeated in the slot template tag.
    </li>
    <li>There may be multiple templates for the same slot. By default these are concatenated.</li>
    <li>
        When the component signature contains a slot named <elm>CONTENT</elm>, then all content of the component instance that is not some (other) slot template, forms a template for this content slot
    </li>
</ul>

Had the slot in our example been named <elm>content</elm> in stead of <elm>rbody</elm>, then the instance would have looked like:
<pre>
<comm>Component instance</comm>
<{}repeat #count=7 num>
  <comm>Content slot template</comm>
  <{}p>This is <{}u>paragraph \{num}<{}/u>.<{}/p>
<{}/repeat>
</pre>
Note how the instance tag <elm>repeat</elm> carries both  the component parameter value <code>#count=7</code> and the slot parameter name <code>num</code>.

<p>Putting it all together, we get:</p>
<demo #srctext=sampleComponent1></demo>

<h3 id=Encapsulate>Encapsulate</h3>
The <elm>COMPONENT</elm> tag may have an attribute <code>encapsulate</code>.
<ul>
    <li>
        <i>Without</i> <code>encapsulate</code>, instances of the component are <i>replaced</i> by the output of the component template.
        <p>Any styling rules of the surrounding document apply to the component output as well, and vice versa.
        <br>To make styling rules apply only to the component content, use CSS class names.
    </li>
    <li>
        <i>With</i> <code>encapsulate</code>, <elm>COMPONENT</elm> defines a new <i>custom element</i>.
        <br>The output of the component template defines the appearance of the element, but is encapsulated inside, using the so-called <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>.
        <p>
            Any styling rules of the surrounding document do not apply to the encapsulated content, and vice versa. The component can have its own style sheet(s), independent of the main document.
            <br>Styling rules and inline styles specifically targeted at the custom element, however, are inherited by the encapsulated content.
        </p>
        <p>
            The generated custom element name is <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">required to contain a hyphen</a>.
            If the component name does not already contain a hyphen, then a prefix 'rhtml-' is prepended.
            <br>This concerns the generated output only, component instances use just the component name, but styling rules targeted at the custom element must use the prefix.
        </p>
    </li>
</ul>
Note: RHTML component templates and slots are not the same as <a href="{MDN}Web/Web_Components">HTML web component templates and slots</a>. It's the same idea but a quite different syntax.


<h3>More examples</h3>
<h4>To-do application</h4>
Here is a to-do application, which splits the collection of items into those done and not done. We use a component <elm>itemlist</elm> to show such a filtered list.
<demo #srctext=sampleTODO>
</demo>

<h4>A recursive component</h4>
<p>Components may be recursive, i.e. refer to themselve.
<br>Here is a recursive component, which images a JavaScript nested list of lists:</p>
<demo #bShow=false #srctext=sampleRecursion></demo>

<h4 id="Redefining">Redefining HTML elements</h4>
<p>Components may redefine HTML elements. To refer to the original element, add a dot to the tag name.
<br>Here is a component that redefines <elm>a</elm> to ensures that all links with no target and an external href, get a <code>target='_blank'</code> attribute:</p>
<demo #srctext=sampleRedefineA #bShow=true>
</demo>
To instantiate the original <elm>a</elm> element, write <elm>a.</elm>.

<h4>Slots within slots</h4>
<p>As there are no restrictions on slot signatures, slots can have slots themselves (subslots). So when a component template instantiates a slot, it may provide templates for its subslots, and these subslots can be instantiated within the slot templates of a component instance.
    <br>This is particularly useful for components with a <elm>CONTENT</elm> slot. The component may provide new or redefined constructs, that are available only within the content of component instances, and that may provide interaction with the component.
</p>
<p>
    This documentation website uses such subslots to redefine <elm>H1</elm>, <elm>H2</elm> within the context of a particular page, so that the given section titles are automatically entered into the table of contents of that page.
</p>


<h4>A radio group component</h4>
HTML provides radio buttons <elm>input type=radio</elm> bearing a name and a fixed value, and buttons with the same name constitute a group.
<br>When they are within a <elm>form</elm>, and the form is submitted to the web server, then the value of the currently selected button within each group is sent to the server.

<p>
    For a reactive application, using <elm>form</elm> works a bit clumsily.
    <br>The following custom does a much better job; it allows one to bind an RVAR, or any other object property, directly to the selected radio button value, without needing a <elm>form</elm> and without repeating any code.
</p>

<demo #srctext="sampleRadioGroup" #bShow=true></demo>
Let me explain the somewhat complicated <elm>radiogroup</elm> signature.
<ul>
    <li>
        <elm>radiogroup</elm> has a parameter 'name' which will be the common name of all radio buttons in the group, and a two-way parameter '@value', that will provide <i>and</i> receive the value of the selected radio button.
    </li>
    <li>
        <elm>radiogroup</elm> has a slot <elm>content</elm> so that the component output can include the content of any radiogroup instance.
    </li>
    <li>
        Slot <elm>content</elm> has itself a slot <elm>radiobutton</elm>, that will be available as a new construct within the radiogroup instance content.
    </li>
    <li>
        <elm>radiobutton</elm> has parameter '#value' that defines the value of the current button, and an optional 'onclick' handler so that component instances can specify this handler without overwriting the 'onclick' handler set by the component template, and a rest parameter '...rest' that will be passed on to the <elm>input type=radio</elm> radio button element.
    </li>
    <li>
        <elm>radiobutton</elm> has a slot <elm>content</elm>, that defines the label content for the current button.
    </li>
</ul>


<h2 id=FORoverSlots><{}FOR of> over component slots</h2>
When a custom construct (a component or a slot) has a slot <i>slot</i>, then instances of the construct may provide multiple templates for that slot.
<br>Now, inside the construct template, one can write:
<pre class=sourcecode>
<{}FOR of=<i>slot</i>>
    <i>Body</i>
<{}/FOR>
</pre>
When this template is instantiated, <i>Body</i> will be repeated for each provided <i>slot</i> template, and <i>slot</i> instances inside <i>Body</i> will be replaced by the output of just that template, rather than by the concatenation of all <i>slot</i> templates.
<p>
Here is a component which allows one to define tables column by column:
</p>
<demo #bShow=false #srctext=sampleTableMaker></demo>


<h2 id=Include><{}INCLUDE src></h2>
<code class=sourcecode><elm>INCLUDE src="<i>URL</i>"</elm><elm>/INCLUDE</elm></code>
allows you to include another RHTML file as if it were inserted into the main file.
<ul>
    <li>
        The file is fetched and compiled <i>asynchronously</i>: compiling the main file will continue while the included file is being fetched.
    </li>
    <li>
        <i>URL</i> may not use string interpolation, because the URL is needed at compile time.</p>
    </li>
    <li>
        <i>URL</i> may be a relative URL. In that case it is interpreted relative to the location of the <i>current</i> HTML file.
    </li>
</ul>

<p>
    To speed things up, you can insert a <a href="{MDN}Web/HTML/Link_types/preload">preload</a> link in the main document header:
</p>
<pre>
<{}link rel=preload href="<i>URL</i>" as=fetch crossorigin>
</pre>
("<code>crossorigin</code>" seems incorrect, but Google Chrome requires it.)

<p>
    A drawback of using <elm>INCLUDE</elm> may be that not all search engines will see the content of the included file.
    <br>Some engines, including Google, do execute JavaScript and will see the full document as it is built by OtoReact, while others won't.
    <br>So if you want all search engines to see the content of your document, then do not use <elm>INCLUDE</elm>.
    <br>An alternative might be to use server-side technology like <a href="{wiki}Server_Side_Includes">Server Side Includes</a> to include your file, if your server supports it.
</p>


<h2 id=MODULE><{}MODULE name?></h2>
A <elm>MODULE</elm> encapsulates a series of components, definitions, scripts and styles(?), that may be imported at other places using <elm>IMPORT</elm>.
<p>
    A <elm>MODULE</elm> has (currently) to be saved in a separate file. The given <code>name</code> is not used.
</p>

<h2 id=Import><{}IMPORT src defines?></h2>
<pre class=sourcecode>
<{}IMPORT async? src="<i>URL</i>" defines?="<i>nameList</i>">
    <i>Signatures</i>
<{}/IMPORT>
</pre>
imports a number of components defined in a <elm>module</elm>, loaded from URL <code>src</code>.
<br>There are two variants:
<ul>
    <li>
        With the <code class=sourcecode>async</code> option, the <elm>IMPORT</elm> element must contain full signatures of the imported components.
        <br>Compiling the document will continue with the provided signatures while the external file is being asynchronously fetched and compiled.
        <br>Only when one of the components has to be instantiated, will OtoReact wait for the completion of the import.
        <p>
            The listed signature need not be identical to the external signature, but must be 'compatible'. E.g., the order of parameters and slots may differ, and the external signature may have optional parameters and slots missing in the listed signature.
            <br>Default values may be different too; Otoreact will use the values listed in the <elm>IMPORT</elm> element.
        </p>
    </li>
    <li>
        Without the <code>async</code> option, the <elm>IMPORT</elm> element needs only specify the names of the imported components.
        <br>Compiling will still continue asynchronously, but as soon as the compiler encounters an invocation of one of these components, it will wait for the external file and get the signatures from there.
        <br>So one can import from multiple modules one after another, and these will still be fetched in parallel.
    </li>
</ul>
Furthermore:
<ul>
    <li>
        Components from the same module may be imported at multiple places and will be fetched and compiled only once.
    </li>
    <li>
        Local variables from the main file are not visible within the module.
    </li>
    <li>
        When there is an attribute <code class=sourcecode>defines="<i>nameList</i>"</code>, then the names in the list, which must be defined as local variables in the module, are made available as local variables in the importing RHTML code.
    </li>
    <li>
        Any <elm>style</elm> definitions in the source module are added to the main document (even those within non-imported components, currently).
    </li>
</ul>
Again, to speed things up, you can insert a <code>preload</code> link in the main document header.

<h2 id=RHTML><{}RHTML #srctext></h2>
<code class=sourcecode><elm>RHTML #srctext="<i>sourceExpr</i>"</elm><elm>/RHTML</elm></code> allows you to interpret dynamically generated text as Reactive HTML.
<p>After each build or update, when the text value of <i>sourceExpr</i> has changed, then this text is compiled as RHTML, built, encapsulated using <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>, and shown.</p>
<p>The demo component on this page uses <elm>RHTML</elm>, of course.</p>
<p>Here you have an <elm>RHTML</elm> within the demo component, i.e. an <elm>RHTML</elm> within an <elm>RHTML</elm>:</p>
<demo #srctext=sampleRHTML></demo>

<h4>Caution</h4>
When you use <elm>RHTML</elm>, you should be cautious of client-side (DOM-based) <a href="{wiki}Cross-site_scripting#Server-side_versus_DOM-based_vulnerabilities">cross-site scripting</a> (XSS, or code injection) attacks, when the text content can be entered by (or influenced by) the user, as on this site.
<br>Client-side XSS is much less dangerous than server-side XSS, but still: don't ever use <elm>RHTML</elm> on sites with any security impact.

<h3>Demo HTML vs RHTML</h3>
In the following demo you can enter a piece of (R)HTML and compare how it is parsed and rendered by the browser without and with OtoReact processing.
<br>Note how OtoReact removes irrelevant white space.

<demo #srcText=demoRendering></demo>

<h2 id=Document><{}DOCUMENT></h2>
<pre class=sourcecode>
    <{}DOCUMENT name=<i>docName</i> params?=<i>nameList</i> window?=<i>windowVar</i> encapsulate?>
        <i>content</i>
    <{}/DOCUMENT>
</pre>
allows you to define a separate document or form, that remains part of the same RHTML application.
<br>
<i>content</i> can be any RHTML code, which is not rendered immediately, but <i>docName</i> is defined as a local variable, bound to an object with the methods listed below, that will create a window either to be shown or printed.
<br>
Any scripts within <i>content</i> are executed within the same browsing context as the main document, and local RHTML variables from the main document are visible in local scripts within <i>content</i>.
<p>
    When <code class=sourcecode>params</code> is specified, then the given parameter names are available within <i>content</i> as local variables.
</p>
<p>
    When <code class=sourcecode>window</code> is specified, then the given <i>windowVar</i> is available within <i>content</i> as a local variable, and will be bound to the created window.
    <br>Note that global variable <code>window</code> refers to the main application window, but may be hidden by the local variable by specifying <code>window="window"</code>.
</p>
<p>
    The available methods are:
</p>
<dl>
    <dt><code><i>docName</i>.open(<i>target?</i>, <i>windowFeatures?</i>, ...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in a separate browser window, using the optionally specified <i>target</i> and <i>windowFeatures</i> as in <a href="{MDN}Web/API/Window/open"><code>Window.open()</code></a>, and parameter names bound to the given <i>args</i>.
        <br>The method returns a reference to the opened window.
    </dd>
    <dt><code><i>docName</i>.print(...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in an invisible browser window with parameter names bound to the given <i>args</i>, and its browser print dialog is opened.
        <br>After the user has closed the print dialog, the invisible window is closed as well.
    </dd>
</dl>

By default, all styling rules attached to the parent document are copied to the new document, but with the option <code class=sourcecode>encapsulate</code> no rules are copied.
<br>You can use <elm>style</elm> to insert styling information, or <elm>RHEAD</elm><elm>LINK &hellip;</elm><elm>/RHEAD</elm> to link an external style sheet.

<demo #srctext=sampleDocument></demo>

<h2><{}RHEAD></h2>
Any child elements of <elm class=sourcecode>RHEAD</elm> are inserted into the current document header, and updated as needed.
<p>
    You can use this e.g. to set a dynamic document title or to add dynamic links, or to specify header content for documents created by <elm>DOCUMENT</elm>.
</p>