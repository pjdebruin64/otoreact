<!DOCTYPE html>
<head>
    <style>
        :root { 
            --OtoRed: #e20000;
            --RedBorder: solid 2px var(--OtoRed);
            font-family: "Segoe UI Web (West European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
            max-width: 900pt; margin: auto;
            border: solid 3pt lightgrey;
            padding: 6pt;
            line-height: 125%;
        }

        .sample {
            display: block;
            margin: 2ex auto; 
            border: var(--RedBorder);
            padding: 1ex 2ex;
            background-color: rgb(225, 255, 181); min-width:375px;
            }
        .sourcecode {
            display: block;
            margin: 2ex auto;
            padding: 8px;
            border: var(--RedBorder);
            width: fit-content;
        }
        pre { margin: 1ex 0;}
        pre, code, elm {
            color: darkblue;
            background-color: rgb(245, 245, 245);
            font-family: 'Lucida Console', monospace;
            font-size: 90%;
        }
        elm::before{
            content: "<";
        }
        elm::after{
            content: ">";
        }

        dt  {font-weight: bold; margin-top: 1ex; }
        ol, ul, li  {margin: 1ex 0}

        table.demo   { margin: 2ex auto; }
        table.demo > tr > th, table.demo > tr > td {
            border: var(--RedBorder);
            vertical-align: top;
        }
        table.demo > tr > th, table.demo > tr > td > * { padding: 8px; }
        table.demo > tr > *:nth-child(1) {background-color: rgb(245, 245, 245);}
        table.demo > tr > *:nth-child(2) {background-color: rgb(225, 255, 181); min-width:375px;}
        table.demo > tr > td:nth-child(1) > pre { color: darkblue; }
        table.demo span.green { color: green; }
        pre.nodisplay {display: none}


        .tic-tac-toe td {
            height:32pt;width: 32pt; 
            border: 2px solid; 
            text-align: center; vertical-align: middle;
        }

        RHTML {display: none;}
    </style>

    <!-- <script type=module src='../OtoReact/OtoReact.js'></script> -->
    <script>
        const s = Date.now();
        function msg(m) {
            console.log(`${Date.now() - s} ${m}`);
        }
    </script>
    <script type=module>

        import {RCompile} from './OtoReact.js';
        msg('OtoReact loaded');
        RCompile(document.body);
        msg('Document compiled');
        document.body.style.display='';
    </script>
    <script>
        delete globalThis.fetch;
        delete globalThis.XMLHttpRequest;
        delete globalThis.import;
    </script>
</head>
<body style='display:none' onload="msg('All loaded')">

<!-- This component ensures that all <a> elements with no target and an external href, get a target='_blank' attribute -->
<component>
    <a href #target? download?></a>
    <template>
        <a #href="href" #target="!target && /^http/i.test(href) ? '_blank' : target" #download="download"><content></content></a>
    </template>
</component>

<h1>Reactive HTML through the OtoReact framework</h1>

<define name=greeting #value=
'`<define rvar=&apos;yourName&apos;></define>
<p>
    What&apos;s your name?
    <input type=text *value="yourName.V">
</p>
<if #cond="yourName.V">
    <p>
        Nice to meet you, \{yourName.V}.
        <br>By the way, your name consists of \{yourName.V.length} characters.
    </p>
</if>`'
></define>

<div class=sample style="width: 300pt; height: 108px;">
    <RHTML>{greeting}</RHTML>
</div>

<p>
    '<i>Reactive web applications</i>', or '<a href="https://en.wikipedia.org/wiki/Single-page_application">Single Page Applications</a>', are web applications that, when possible, react immediately on user input, timer events etc, or server data requested by the application, instead of waiting for the web server to generate and send a new HTML page.
    <br>A tiny example you see above; please enter some data.
</p>
<p>
    When some server data is needed, then the application requests just the data and updates the shown page, instead of sending all input fields to the server and having the server create and send a new page.
    <br>This results in both a much better user experience and much less server load.
</p>
<p>
    "OtoReact" is a small and fast framework to attain this by loading so-called "Reactive HTML" (or "RHTML") straight into the browser.
    <br>Reactive HTML is parsed by the browser  itself, and compiled and executed by OtoReact within milliseconds.
    <br>Reactive HTML is very easy to learn, and one doesn't need to install a compiler, a bunch of libraries, or <i>anything</i>.
    <br>Just a text editor and access to a web server (<i>any</i> web server) suffice.
    <br>Reactive HTML has a powerful component system, routing, pretty much everything you need.
</p>
<p>
    The tiny example above is generated by the following piece of Reactive HTML (and yes, the current web page uses RHTML to show you <i>exactly</i> the same piece of code as is executed above):
</p>
<pre class=sourcecode #innerText="greeting"></pre>

<p>
    Reactivity is always attained by means of JavaScript programming code running inside the web browser. The javaScript code has to manipulate the so-called "DOM" ("Document Object Model"), which is the internal object model of a web page ("document").
    <br>Writing such JavaScript by hand can get quite complicated and might result in very cluttered programming code.
</p>
<p>
    There exist quite a number of libraries and frameworks to make it easier to build reactive web applications. I distinguish two main categories:
</p>
<ol>
    <li>
        Some, like <a href="https://jquery.com/">JQuery</a> and <a href="https://reactjs.org/">React</a>, offer tools to make it easier to manipulate the DOM.
        <br>All manipulation is still done from within the JavaScript you write, and you need a good understanding of DOM manipulation and JavaScript in general.
        <br>The respective libraries can in some cases be loaded straight into the browser without compilation.
    </li>
    <li>
        Others, like <a href="https://angular.io/">Angular</a> and <a href="https://svelte.dev/">Svelte</a>, make a clean separation between the programming code and presentation. The JavaScript you write contains just the data model and the data manipulation you need; the actual web page is described by a template file containing HTML enriched with directives and other stuff.
        <br>You don't need write code to manipulate the DOM at all anymore; this is done by the framework.
        <br>The source code files have to be compiled on you development machine. You need to install the compiler, and quite some modules for each application (which for Angular may take more than 1GB per application).
    </li>
</ol>
<p>
    Reactive HTML gives you the advantages of describing the desired reactive layout by a HTML template, without the hassle of installing and using a compiler and managing quite a number of configuration files.
</p>

<import src="./demo.html">
    <demo content bshow></demo>
</import>

<!-- Component to demonstrate RHTML -->
<component>
    <demo content #bshow=true></demo>
    <!-- Beware: any braces in the content attribute must be prefixed with a '\' -->
    <script>
        function ColorCode(html) {
            return html.replace(
                    /[<&]/g, c => ({'<': '&lt;', '&': '&amp;'}[c])
                ).replace(/\/\/[^\n]*|&lt;!--.*?-->|\/\*.*?\*\//gs, "<span class=green>$&</span>");
        }
    </script>
    
    <template>
        <define rvar=MyRVAR #value="content.match(/^\s*(.*?)\s*$/s)[1]"></define>
        <define rvar=rShow  #value="bshow"></define>
        <table. class=demo>
            <tr.><th.>
                <button onclick="rShow.V=!rShow.V" reacton=rShow>{rShow.V ? 'Hide' : 'Show'}</button>
                Editable source code
            </th.><th.>Live result</th.></tr.>
            <tr.>
                <td.>
                    <pre #class:nodisplay="!rShow.V" reactOn=rShow
                    contenteditable=true spellcheck=false #innerHTML="ColorCode(MyRVAR.V)" *innerText="MyRVAR.V"></pre>
                </td.>
                <td.><div>
                    <RHTML reacton=MyRVAR>
                        {MyRVAR.V}
                    </RHTML>
                </div></td.>
            </tr.>
        </table.>
    </template>
</component>

<h2>Limitations inflicted by the parser</h2>
Using the browser HTML parser inflicts us some limitations, as it isn't tailored for RHTML. Such as:
<dl>
    <dt>Re-arranged elements</dt>
    <dd>
        The HTML parser forces elements to be arranged according to HTML rules, and will <i>silently</i> rearrange them if they are not.
        <br>Notably:
        <ul>
            <li>Table-related elements table, tr, thead, tbody, tfoot may only contain appropriate children.
                <br>If, e.g., a <elm>table</elm> would contain a <elm>for</elm> loop containing a <elm>tr</elm>:
                <pre><elm>table</elm>
    <elm>for let=x #of=&hellip;</elm>
        <elm>tr</elm> &hellip; \{x\} &hellip; <elm>/tr</elm>
    <elm>/for</elm>
<elm>/table</elm></pre>
                , then the parser will move the <elm>for</elm> <i>before</i> the <elm>table</elm>, while leaving the <elm>tr</elm> inside.
                <br>Thus OtoReact sees:
                <pre><elm>for let=x #of=&hellip;</elm><elm>/for</elm>
<elm>table</elm><elm>tr</elm> &hellip; \{x\}&hellip; <elm>/tr</elm><elm>/table</elm></pre>
                , and may give a misleading error about <code>x</code> being undefined.
                <br>To get the loop right, OtoReact allows you to put a dot after any tag name, so the parser won't interfere:
                <pre><elm>table.</elm>
    <elm>for let=x #of=&hellip;</elm>
        <elm>tr.</elm> &hellip; \{x\} &hellip; <elm>/tr.</elm>
    <elm>/for</elm>
<elm>/table.</elm></pre>
                When compiling, the dot will be removed. 
            </li>
            <li>
                The paragraph-element <elm>p</elm> does not allow block-level elements inside, but allows unknown elements.
                <br>Thus, if you write
                <pre><elm>p</elm> &hellip; <elm>if &hellip;</elm><elm>ul</elm> &hellip; <elm>/ul</elm><elm>/if</elm></pre>
                , without closing the <elm>p</elm>, either because you know the parser will automatically close it when needed, or because you didn't know <elm>ul</elm> is not allowed inside <elm>p</elm>, then the parser will silently close the <elm>p</elm> <i>after</i> the unknown <elm>if</elm>, and the <elm>ul</elm> ends up <i>outside</i> the <elm>if</elm>, without you or OtoReact being informed:
                <pre><elm>p</elm> &hellip; <elm>if &hellip;</elm><elm>/if</elm><elm>/p</elm>
<elm>ul</elm> &hellip; <elm>/ul</elm></pre>
                To avoid this, make a habit of always closing all elements.
            </li>
        </ul>
    </dd>
    <dt>Attribute names are considered lowercase</dt>
    <dd>
        As attribute names in HTML are case-insensitive, the parser makes them all silently lowercase.
        <br>As RHTML sometimes uses attribute names as bound variables, such variables will be lowercase, even if you wrote them with uppercase, and OtoReact can't warn you about this.
        <br>There is also a feature for conditional classes (<code>#class:someclass="someBoolean"</code>), which will only work for class names in lowercase.
    </dd>
    <dt>Missing error messages</dt>
    <dd>
        There are more cases where the browser doesn't inform you of errors, which may result in strange behaviour.
    </dd>
</dl>
I imagine Reactive HTML one day being natively supported by the browser. In that case, these limitations can be lifted.

<h2>Setup</h2>
<ol>
    <li>
        Download <a href="./OtoReact.js" download>OtoReact.js</a> and place it somewhere on your server.
        <br>It's just 30 Kilobyte.
    </li>
    <li>
        Import the OtoReact compiler into your application:
        <pre>import \{ RCompile \} from './OtoReact.js';</pre>
    </li>
    <li>
        Invoke the compiler on the part(s) of your page you wish to be reactive, e.g.:
        <pre>RCompile( document.body );</pre>
    </li>
</ol>
Both code lines can either be placed right into you HTML file:
<pre class=sourcecode>
&lt;script type=module>
    import \{ RCompile \} from './OtoReact.js';
    RCompile( document.body );
&lt;/script>
</pre>
, or inside a JavaScript (or TypeScript) module you load from your HTML file.

<h2>Text with embedded expressions</h2>
All text content and all HTML attributes inside RHTML code, except event handlers, may contained embedded expressions between braces.
<br>To include a normal pair of braces, at least one of them must be escaped with a backslash.
<demo content="1 + 1 = \{1 + 1\}
\\{ Check \\}"></demo>

You can modify the snippet of source code above and see its result immediately.
<p>
    (This interactive demo is itself defined as an RHTML component.)
</p>


<h2>RVAR(): Reactive VARiable's</h2>
<p>
    Reactive variables (RVAR's) are objects containing variable data on which RHTML elements may react.
    <br>Anytime the value of an RVAR changes, the reacting elements will be updated.
</p>
<p>
    RVAR's are created either by calling <code>RVAR(name?, value?)</code> from JavaScript, or by using the <elm>define rvar</elm> directive, see below.
    <br>The created RVAR is returned and may be stored in a local variable.
    <br>If you supply a name, it will be registered in the global environment under that name and will be visible anywhere.
    <br>So if you write:
    <pre>
&lt;script type=module>
    let A = RVAR('B');
    &hellip;
    </pre>
    , then it will be available as <code>A</code> just inside this script, and also as <code>B</code> anywhere.
</p>
<p>
    You may inform OtoReact which fragments of RHTML should react on which RVAR's, by using the <elm>REACT</elm> element or the <code>react</code> attribute, see below.
    <br>If you do not, then the full trunk of compiled RHTML will react on all RVAR's.
</p>

<demo content=
"<script type=module>
    // Create a &quot;Reactive variable&quot; with a name and an initial value
    RVAR('yourName');
    /* Now 'yourName' has been added to the global environment,
      and 'yourName.V' refers to the value of the variable,
      so that assignments to this value can be tracked. */
</script>

<p>What's your name?
    <input type=text *value=&quot;yourName.V&quot;>
    <!-- The &quot;*&quot; introduces an output binding for the input element.
      Anytime an input event happens, 'yourName.V' will be updated,
      and the DOM as well  -->
</p>
<if #cond=&quot;yourName.V&quot;>
    <p>Nice to meet you, \{yourName.V\}.
    <br>By the way, your name consists of \{yourName.V.length\} characters.
    </p>
</if>"></demo>

<h2>Local and global variables</h2>

<h2>Elements</h2>

<h3>Attributes and properties</h3>

<h3>Events</h3>

<h3>Classes</h3>

<h3>Styles</h3>

<h3>Apply</h3>

<h3>&lt;IF #cond&gt;</h3>

<h3>&lt;CASE&gt; &lt;WHEN #cond&gt; &lt;ELSE&gt;</h3>

<h3>&lt;FOR let #of&gt;</h3>
<demo content="<!-- Here we use a local RVAR -->
<define rvar=Participants #value=&quot;['Joe', 'Mary', 'Eileen']&quot;></define>

<p><b>Participants:</b></p>
<ul>
    <for let=participant #of=&quot;Participants.V&quot;>
        <li>\{participant\}</li>
    </for>
</ul>
<p>
    New participant (Enter):
    <br>
    <input type=text 
        onchange=&quot;if(this.value)\{ Participants.U.push(this.value); this.value=''; \}&quot;
    >
    <!-- &quot;this&quot; in all RHTML event handlers refers to the target element. -->
    <!-- Getting &quot;Participants.U&quot; means &quot;Participants&quot; will be marked as changed, 
        even though it is not assigned to. -->
</p>">
</demo>

<h3>&lt;DEFINE var #value&gt;</h3>

<h3>&lt;SCRIPT&gt;</h3>

<h3>&lt;COMPONENT&gt;</h3>
<demo content="<script type=module>
    // Define the data model of our todo list
    let TODO = RVAR('TODO',
        [['Visit Joe', true], ['Fishing',false], ['Sleeping',false]]
    );
    // Adding an item
    globalThis.AddItem = function(inputElement) \{
        if (inputElement.value) \{
            TODO.U.push( [inputElement.value, false] );
            inputElement.value = '';
        \}
    \}
</script>

<!-- Define a component, showing a filtered list of to-do-items, with a caption -->
<component>
    <!-- This is the component signature -->
    <itemlist caption bDone></itemlist>

    <template>
        <p><b>\{caption\}</b></p>
        <p>
            <for let=item #of=TODO.V updates=TODO>
                <!-- 'bdone' must be in lowercase -->
                <if cond='item[1] == bdone'>
                    <label>
                        <input type=checkbox @checked='item.U[1]'> 
                        \{item[0]\}
                    </label>
                    <br>
                </if>
            </for>
        </p>
    </template>
</component>

<!-- These elements should react on changes in RVAR 'TODO' -->
<react on='TODO'>
    <itemlist caption='To do:' #bDone=false></itemlist>
    <itemlist caption='Done:'  #bDone=true ></itemlist>
</react>
<p>
    New item (Enter):
    <br>
    <input type=text onchange=&quot;AddItem(this)&quot;>
</p>">
</demo>


Here is a component that redefines <elm>a</elm> to ensures that all links with no target and an external href, get a target='_blank' attribute:
<demo content="<component>
    <a href #target? download?></a>
    <template>
        <a #href=&quot;href&quot; 
            #target=&quot;!target && /^http/i.test(href) ? '_blank' : target&quot; 
            #download=&quot;download&quot;>
            <content></content>
        </a>
    </template>
</component>

This link opens in a blank window:
<a href=&quot;https://www.otolift.com/&quot;>Otolift Stairlifts</a>">
</demo>


<h3>&lt;REACT on&gt;, reacton</h3>
<demo #bShow=false content=
"<div style=&quot;display: grid; width: 300pt; background-color: white;&quot;>
    <div style=&quot;grid-area: 1/1 / 1/span 2; text-align: center;&quot;>
        <b>Tic-Tac-Toe</b>
    </div>

    <script type=module>
        function Cell() \{return \{V: null\}; \}
        function Row()  \{return [Cell(), Cell(), Cell()]; \}
        function Board() \{return [Row(), Row(), Row()]; \}
        let board =     RVAR('board');
        let toMove =    RVAR('toMove', '✕');
        let winner =    RVAR('winner');
        let count = 0;

        globalThis.ClearAll = function() \{
            board.V = Board();
            winner.V = null;
            count = 0;
        \}
        ClearAll();

        globalThis.Move = function(cell) \{
            count++;
            cell.U.V = toMove.V;
            toMove.V = (toMove.V=='✕' ? '◯' : '✕');
            winner.V = CheckWinner(board.V) || count==9;
        \}

        function CheckRow(c1, c2, c3) \{
            return (c1.V && c1.V == c2.V && c2.V == c3.V
                ? c1.V : null);
        \}
        function CheckWinner(board) \{
            let w = null;
            for (let i=0;i<3;i++) \{
                w ||= CheckRow(...board[i]);
                w ||= CheckRow(board[0][i], board[1][i], board[2][i]);
            \}
            for (let i=-1;i<=1; i+=2)
                w ||= CheckRow(board[0][1+i], board[1][1], board[2][1-i]);
            return w;
        \}
    </script>

    <table. class=tic-tac-toe style=&quot;grid-area: 2/1; width: fit-content; margin:1ex&quot;>
        <for let=row #of=&quot;board.V&quot;>
            <tr.>
                <for let=cell #of=row updates=board>
                    <td. onclick=&quot;!winner.V && !cell.V && Move(cell)&quot;
                    >\{cell.V ?? ''\}</td.>
                </for>
            </tr.>
        </for>
    </table.>
    <div style=&quot;grid-row: 2; grid-column: 2;&quot;>
        <p>
            <case>
                <when #cond=&quot;winner.V==true&quot;><b>It's a draw.</b></when>
                <when #cond=&quot;winner.V&quot;><b>The winner is: <large>\{winner.V\}</large></b></when>
                <else>Player to move: \{toMove.V\}</else>
            </case>
        </p>
        <button onclick=&quot;ClearAll()&quot;>Clear</button>
    </div>
</div>">
</demo>


<h3>&lt;FOR #of&gt; over component slots</h3>
Here is a component which allows one to define tables column by column.
<demo #bShow=false content="<script>
    globalThis.data = [\{name:'Piet', age:18\}, \{name:'Tine', age:19\}];
</script>
    
<component>
    <TABLEMAKER datasource>
        <HDEF></HDEF>
        <DDEF item></DDEF>
    </TABLEMAKER>

    <template>
        <table.>
            <tr.>
                <for of=HDEF>
                    <th.><HDEF></HDEF></th.>
                </for>
            </tr.>
            <for let=rec #of='datasource'>
                <tr.>
                    <for of=DDEF>
                        <td.><DDEF #item=rec></DDEF></th>
                    </for>
                </tr.>
            </for>
        </table.>
    </template>
</component>

<!-- Now the actual table definition: -->

<tablemaker #datasource='globalThis.data'>
    <HDEF>Naam</HDEF>
    <DDEF item>\{item.name\}</DDEF>

    <HDEF>Leeftijd</HDEF>
    <DDEF item=record>\{record.age\}</DDEF>
</tablemaker>"
>
</demo>

<h3>&lt;INCLUDE src&gt;</h3>
<elm>INCLUDE src="&hellip;"</elm> allows you to include another RHTML file as if it were inserted into the main file.
<br>The file is fetched, compiled and build <i>asynchronously</i>: compiling the main file will continue while the file is being fetched.
<p>
    You can insert code to be shown till the including is fulfilled.
</p>

<h3>&lt;IMPORT src&gt;</h3>

<h3>&lt;RHTML&gt;</h3>

<h3>&lt;WINDOW&gt;</h3>

<h3>&lt;PRINT&gt;</h3>

<h3>Routing</h3>

<h3>Persistence</h3>

</body>