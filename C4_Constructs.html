<h1>RHTML Constructs</h1>

N.B. All construct attributes which must be JavaScript expressions, like <code>cond</code> and <code>of</code>, may optionally be prefixed with a hash mark: <code>cond</code>, <code>of</code>.
<br>Their meaning remains the same.

<p>
    Any attribute starting with an underscore "_" is ignored. So one can use this to insert a comment right between attributes (<code>_="Some comment"</code>) or to comment out some attribute.
</p>

<p>
    Otherwise, it is an error when a construct instance has unknown attributes.
</p>

<h2 id=DEFINE><{}DEFINE var #value>, Local Variables</h2>
<pre class=sourcecode>
<elm>DEFINE var=<i>name</i> #value="<i>expression</i>"</elm><elm>/DEFINE</elm>
</pre>
<p>
    introduces a local <u>immutable</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>Alternatively, one can give an interpolated string: <code>value="<i>string</i>"</code>.
    So for an expression, the '<code>#</code>' is required.
    <br>The variable is visible in all local expressions from the <elm>DEFINE</elm> till the end of the enclosing element, except when obscured by nested definitions.
    <br>It cannot be assigned to, but when its value is an RVAR or some other object, then one can of course modify its properties.
</p>
<p>
    The expression is, by default, evaluated only once, when the respective DOM-trunk is built, not when it is updated.
</p>
<p>When you add an attribute <code class=sourcecode>updating</code> or <code class=sourcecode>reacting</code> (without value), then the expression is re-evaluated at every update.</p>
<pre class=sourcecode><elm>DEFINE rvar=<i>name</i> #value?="<i>expression</i>" store?=<i>storage</i> async?</elm><elm>/DEFINE</elm></pre>
<p>
    introduces a local <u>reactive</u> variable <code><i>name</i></code>, with a value computed by <code><i>expression</i></code>.
    <br>This is equivalent to <code><elm>DEFINE var=<i>name</i> #value="RVAR(null, <i>expression</i>, <i>storage</i>)"</elm><elm>/DEFINE</elm></code>.
    <br>When <code class=sourcecode>store</code> is specified, then the rvar value is stored in the given storage, see <a href=#Persistence>Persistence</a>.
</p>
<p>
    When <code class=sourcecode>async</code> is specified, then <i>expression</i> must yield a <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
    The value of the rvar wil initially be <code>undefined</code>, and when the promise resolves to a value, then the rvar will be set to that value.
</p>
<p><elm>DEFINE</elm> may not have any child nodes, other than comments or white space.</p>
<p>
    <elm>DEFINE</elm> may be abbreviated to <elm class=sourcecode>DEF</elm>.
</p>
<p id=lexicalScoping>
    Local variable names (including loop variables and component parameters) obey strict <a href="{wiki}Scope_(computer_science)#Lexical_scope">lexical scoping</a> rules:
</p>
<demo #srctext=demoScoping></demo>

<h2 id=CASE><{}CASE> <{}WHEN cond> <{}ELSE></h2>
<pre class=sourcecode>
<{}CASE hiding?>
    <{}WHEN cond="<i>expr</i>"> <i>WhenPart</i> <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre> is a conditional piece of RHTML.
<ul>
    <li>
        There may be multiple <elm>WHEN</elm> parts.
    </li>
    <li>
        The first <i>WhenPart</i> for which the value of <i>expr</i> is true (or <a href="{MDN}Glossary/Truthy">truthy</a>), is included in the document.
    </li>
    <li>
        If none is truthy, and there is an <elm>ELSE</elm> part, then <i>ElsePart</i> is included.
    </li>
    <li>
        When <code class=sourcecode>hiding</code> is specified, then <i>all</i> alternatives will be included in the DOM tree, but the unwanted ones will be <a href="{MDN}HTML/Global_attributes/hidden">hidden</a>.
        <br>This may result in slower initial building, but faster switching between alternatives (especially when using <a href="thisreactson"><code>thisreactson</code></a>).
    </li>
</ul>
<h3 id=PatternMatching>Pattern Matching</h3>
Furthermore, <elm>CASE</elm> can select an alternative based on <i>pattern matching</i> against a given string value.
<p>Substrings of the value can be captured into new local variables.
<p>There are three variants of patterns:
</p>
<pre class="sourcecode">
<{}CASE #value="<i>expr</i>">
    <{}WHEN match="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN urlmatch="<i>pattern</i>"> &hellip; <{}/WHEN>
    <{}WHEN regmatch="<i>regExp</i>" captures?="<i>nameList</i>"> &hellip; <{}/WHEN>
    &hellip;
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
All three variants are case-insensitive, and all can be combined with a simple condition <code>cond</code>.
<dl>
    <dt><code>match="<i>pattern</i>"</code></dt>
    <dd>
        The value is matched against the given 'simple pattern', which may contain the following wildcards:
        <ul>
            <li><code>?</code> matches any single character</li>
            <li><code>*</code> matches any string of characters</li>
            <li><code>[<i>charString</i>]</code> matches any character in <i>charString</i>, where all <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">rules for JavaScript character classes</a> apply</li>
            <li>
                <code>\{ <i>varName</i> \}</code> matches non-greedily any string of characters, and 
                <ul><li>
                    The matched string will be captured in <a href=#Variables>local variable</a> <i>varName</i>
                </li></ul>
            </li>
            <li><code>\</code> followed by any character matches just that character</li>
        </ul>
        The whole value has to match, not just a substring.
    </dd>
    <dt><code>urlmatch="<i>pattern</i>"</code></dt>
    <dd>
        This form is meant to be matched against (parts of) an URL, and is useful for routing.
        <br>The recognized patterns are the same simple patterns as above, but any substring captured in a local variable will be <a href="{wiki}Percent-encoding">URL-decoded</a>.
    </dd>

    <dt><code>regmatch="<i>regExp</i>" captures?="<i>nameList</i>"</code></dt>
    <dd>
        <i>regExp</i> can be any JavaScript <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Cheatsheet">regular expression pattern</a>.
        <p>The match succeeds when a substring of the string value matches against <i>regExp</i>.</p>
        <p>When <code>captures="<i>nameList</i>"</code> is specified, then the values captured by any <a href="{MDN}Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges#types">capturing groups</a> in the pattern will be stored in local variables with the specified names, in order of appearance. Use empty names to skip unneeded capturing groups.</p>
    </dd>
</dl>
Patterns with captures cannot be combined with <code>hiding</code>, as no DOM-tree can be built when the variable values are unknown.


<h2 id=IF><{}IF cond> <{}THEN> <{}ELSE></h2>
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <i>ThenPart</i>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
or
<pre class=sourcecode>
<{}IF cond="<i>expr</i>">
    <{}THEN> <i>ThenPart</i> <{}/THEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/IF>
</pre>
is the same as:
<pre>
<{}CASE>
    <{}WHEN cond="<i>expr</i>"> <i>ThenPart</i> <{}/WHEN>
    [<{}ELSE> <i>ElsePart</i> <{}/ELSE>]
<{}/CASE>
</pre>
<p>
    All hiding and pattern-matching features of <elm>CASE</elm><elm>WHEN</elm> apply to <elm>IF</elm> as well.
</p>


<h2 id=FOR><{}FOR let of index?></h2>
<pre class="sourcecode">
<{}FOR let=<i>name</i> of="<i>iterableExpression</i>">
    <i>BodyPart</i>
<{}/FOR>
</pre>
<p>
    The normal FOR-construct repeats its <i>BodyPart</i> for each item yielded by the value of <i>iterableExpression</i>.
</p>
<p>
    The value of <i>iterableExpression</i> must be an <a href="{MDN}Web/JavaScript/Reference/Statements/for...of">iterable object</a>, e.g. an Array, or the result of the RHTML <a href="#rangeFunction">range function</a>, if you want a numeric repetition. 
</p>
<p>
    Attribute <code>let=<i>name</i></code> (or <code>var=<i>name</i></code>) is compulsory, but <i>name</i> may be missing or empty. When nonempty, <i>name</i> becomes a local (immutable) variable bound to the respective item.
</p>

<demo #srctext="sampleParticipants">
</demo>

Further on, <elm>FOR</elm> can have the following attributes:
<dl>
    <dt><code>index=<i>indexName</i></code></dt>
    <dd>
        When present, <i>indexName</i> becomes a local variable bound to the zero-based index number: 0 for the first item, 1 for the second, and so on.
        <br>When <code>index</code> is present but <i>indexName</i> omitted, then <code>index='index'</code> is assumed.
    </dd>

    <dt><code>previous=<i>prevName</i></code></dt>
    <dd>
        When present, <i>prevName</i> becomes a local variable bound to the <i>preceeding</i> item in the iteration, or <code>undefined</code> for the first item.
        <br>This allows one to easily check for changed properties within the iteration.
        <br>When <i>prevName</i> is omitted, then <code>'previous'</code> is assumed.
    </dd>
    
    <dt><code>next=<i>nextName</i></code></dt>
    <dd>
        In the same way, <i>nextName</i> becomes bound to the <i>next</i> item in the iteration.
    </dd>

    <dt><code>key="<i>keyExpression</i>"</code></dt>
    <dd>
        When a FOR-construct has to be updated, items in the iteration may have been removed, added, reordered, or replaced.
        <br>OtoReact does not make any assumption about these items; it will by default completely rebuild the FOR DOM-tree on every update.
        <p>
            You may however specify a <i>keyExpression</i>, which may refer to <i>name</i> and <i>indexName</i> and should compute a unique "key" value for each item in the iteration.
            <br>In that case OtoReact will use this to identify old and new items. When an item in a new iteration has the same key value as an item in the previous iteration, then OtoReact won't rebuild its DOM-tree, but will move its previous DOM-tree to its (possibly) new position and will update it in-place.
            <br>This has the following effects:
        </p>
        <ul>
            <li>It is faster</li>
            <li>If any input element in the tree had received focus or inputdata, then it will keep that focus or data</li>
            <li>Any <code>oncreate</code> handlers won be executed again</li>
            <li>If the RHTML in <i>BodyPart</i> created any RVAR's or other objects, then these won't be renewed but will keep their previous value</li>
        </ul>
        <p>
            When items in the iteration are always distinct, then the key may be the item itself: <code>key=<i>name</i></code>.
            <br>When items in the iteration always remain in place, then the key may be the index number: <code>key=<i>indexName</i></code>
        </p>
    </dd>

    <dt><code>hash="<i>hashExpressionList</i>"</code></dt>
    <dd>
        Processing can be further speeded up by specifying one or more comma-separated "hash expressions".
        <br>OtoReact cannot quickly detect whether some property (deep) inside an object has changed, so it will by default update all subtrees when updating the FOR-construct, meaning it will recompute all properties, conditions, et cetera.
        <p>
            If, however, you specify a <i>hashExpressionList</i>, then OtoReact will assume an item (identified by its key) has not changed when the values of the expressions in <i>hashExpressionList</i> haven't changed, and it won't spend time on updating its DOM subtree.
        </p>
        <p>
            The hash expression need not be a real <a href="{wiki}Hash_function">hash function</a>; it could be a possibly long string.
            <br>If, e.g., items are read from an external source and parsed using <code>JSON.parse</code>, then one could preserve the unparsed string and use it as the hash value.
        </p>
    </dd>

    <dt><code>reacting</code> (or <code>reactive</code>)</dt>
    <dd>
        The loop variable <i>name</i> is immutable, but events may modify its properties. If you need the DOM subtree to react on property changes, then you can add attribute <code>reacting</code> (or <code>reactive</code>) to make <i>name</i> reactive.
        <p>
            When <code>reacting</code> is present, then <i>name</i> gets a property <code><i>name</i>.U</code>, which yields the value of <i>name</i> and marks it as dirty, just as with <a href="#RVAR">reactive variables</a>.
            <br><i>Name</i> does not become a full RVAR: one cannot get or set <code><i>name</i>.V</code>. One could call it an RVAR-light.
        </p>
        <p>
            Note that just <i>name</i> is marked dirty, not the source (array) of the iteration. If you need elements of your application <i>outside</i> the local subtree to react on changes, then you can use the <code>updates</code> attribute described below.
        </p>
    </dd>
    <dt><code>updates="<i>rvarList</i>"</code></dt>
    <dd>
        If you want changes to properties of <i>name</i> to have reactions outside the local subtree, then you can use <code>updates="<i>rvarList</i>"</code>.
        <br><i>rvarList</i> must be a comma-separated list of zero or more RVAR's.
        <p>
            When present, then <i>name</i> becomes reacting as above, and whenever <i>name</i> is marked dirty (by a reference to <code><i>name</i>.U</code>), then all RVAR's in <i>rvarList</i>> will be marked dirty too.
        </p>
        <p>You can find an example of this in the todo-list below: whenever an item is (un)marked as done, then both lists that depend on <code>TODO</code> are updated.</p>
    </dd>
</dl>

<h2 id=SCRIPT><{}SCRIPT type? src? defines?></h2>
<p>
    Scripts can be included almost anywhere in your application, either embedded or through an external <code>src</code> reference.
</p>
<p>
    External scripts may be written in <a href="https://www.typescriptlang.org/">TypeScript</a>, of course.
</p>
<p>
    You have to be aware that scripts included in the main document, except those tagged with <code>nomodule</code>, are automatically executed by the browser before OtoReact has had any opportunity to intervene.
</p>
<p>
    You have also to be aware that scripts in browser-based JavaScript come in two flavours: <i>classic</i> JavaScript and JavaScript <i>modules</i>, see <a href="{MDN}Web/HTML/Element/script">MDN</a>, and that OtoReact is imported as a JavaScript <a href="{MDN}Web/JavaScript/Guide/Modules"><i>module</i></a>.
</p>
<p>
    Outside the main document, both classic and module scripts will be executed by OtoReact, and OtoReact add a number of extra options.
    <br>Together, you have the following alternatives:
</p>
<dl>
    <dt><elm>SCRIPT src?</elm> or <elm>SCRIPT type="<b>text/javascript</b>" src?</elm></dt>
    <dd>
        <ul>
            <li>
                When these elements occur <i>in the main document file</i>, the browser will execute the internal or external script as <u>classic</u> JavaScript <i>while parsing the file</i>.
                <br>That is <i>before</i> OtoReact has been loaded, so it cannot immediately execute OtoReact functions like <code>RVAR</code>.
                <br>Any names defined in the script are automatically put in the global scope and are available in RHTML code.
                <br>One can use <a href="{MDN}Web/JavaScript/Reference/Strict_mode">strict mode</a> by placing the statement <code>"use strict";</code> or <code>'use strict';</code> (including the quotes) at the beginning of the script.
                <br>One can add <code>async</code> or <code>defer</code> as described on <a href="{MDN}Web/HTML/Element/script">MDN</a>.
            </li>
            <li>
                <i>Outside</i> the main file, in included or imported RHTML files, OtoReact will execute the internal or external script as classic JavaScript <i>while compiling the file</i>.
                <br>OtoReact functions are available.
                <br>OtoReact tries to mimick  browser behaviour, but it cannot detect which names have been defined, and does not automatically put them in global scope. You need to explicitly define them as properties of the global object, as with <code>type="module"</code>, or switch to <elm>SCRIPT type="otoreact" defines?="<i>nameList</i>"</elm>.
                <br>One can use strict mode as above.
                <br>With attribute <code>async</code>, fetching and executing is done asynchronously, and awaited for when the respective DOM tree is being built.
                <br>With attribute <code>defer</code>, execution is postponed till the first time the DOM tree is being built.
            </li>
        </ul>
    </dd>

    <dt><elm>SCRIPT type="<b>module</b>" src?</elm></dt>
    <dd>
        <ul>
            <li>
                When this element occurs <i>in the main document file</i>, the browser will asynchronously execute the internal or external script as a JavaScript <u>module</u>. Multiple module scripts are executed in order of appearance.
                <br>That means that it will be executed after the whole document has been parsed and, assuming that you import and call OtoReact at the top of your document, <i>after</i> OtoReact has been loaded and has compiled your document, but <i>before</i> the document has been built.
                <br>To execute OtoReact functions, one can either import the functions from OtoReact.js, or invoke them from global scope.
                <br>Names defined in a JavaScript module are not automatically put in the global scope. You have to explicitly define them as properties of the global object: <code class=sourcecode>window.<i>name</i> = &hellip;</code> or <a href="{MDN}Web/JavaScript/Reference/Global_Objects/globalThis" title="What is globalThis?">better</a>: <code class=sourcecode>globalThis.<i>name</i> = &hellip;</code> before they are available in RHTML code.
                <br>Modules use strict mode automatically.
            </li>
            <li>
                <i>Outside</i> the main file, OtoReact will asynchronously execute the script as a JavaScript module, and await for it when building the DOM tree.
            </li>
        </ul>
    </dd>

    <dt><elm>SCRIPT type="<b>otoreact</b>" src? defines?="<i>nameList</i>"</elm>,
        <br><elm>SCRIPT type="<b>otoreact/global</b>" src? defines?="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously fetches the internal or external script, and executes it once as <i>classic</i> JavaScript <i>the first time the DOM tree is being built</i>.
        <br>Names are not automatically defined in global scope, but one can provide a comma-separated <code>defines="<i>nameList</i>"</code> telling which names should be put in global scope.
        <br>OtoReact invokes strict mode automatically.
    </dd>
    
    <dt><elm>SCRIPT type="<b>otoreact/static</b>" src? defines="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously fetches the internal or external script, and executes it once as <i>classic</i> JavaScript <i>the first time the DOM tree is being built</i>.
        <br>Names listed in <i>nameList</i> are not put in global scope, but are defined <i>as OtoReact local variables</i>.
        <p>
            So when this type of script is used inside, e.g., a component, then the script is executed just once, the values of the listed names are internally remembered, and visible as local variables just inside the component.
        </p>
    </dd>    
    
    <dt><elm>SCRIPT type="<b>otoreact/local</b>" src? defines?="<i>nameList</i>" updating?</elm></dt>
    <dd>
        This type of script is executed <i>every time</i> the surrounding RHTML is being built.
        <br>With attribute <code>updating</code>, the script is executed every time the surrounding RHTML is being built <i>or updated</i>.
        <br>Local variables from the surrounding RHTML are visible inside the script, and names listed in <i>nameList</i> are defined <i>as new OtoReact local variables</i>.
        <p>
            So when this type of script is used inside a component template, then each instance of the component will have its own set of data.
        </p>
    </dd>

    <dt><elm>SCRIPT type="<b>otoreact; type=module</b>" src? defines?="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously executes the internal or external script as a JavaScript <u>module</u>.
        <br>Fetching and executing the script is initiated when compiling the containing file, and awaited for when first building the DOM tree.
        <br>When a <i>nameList</i> is given, then the script is required to <u>export</u> the listed names, and OtoReact will define them <i>in global scope</i>.
    </dd>
    <dt><elm>SCRIPT type="<b>otoreact/static; type=module</b>" src? defines="<i>nameList</i>"</elm></dt>
    <dd>
        OtoReact asynchronously executes the internal or external script as a JavaScript <u>module</u>.
        <br>Fetching and executing the script is initiated when compiling the containing file, and awaited for when first building the DOM tree.
        <br>The script is required to export the names listed in <i>nameList</i>, and OtoReact will define them <i>as OtoReact local variables</i>.
    </dd>
</dl>

<h2 id=REACT><{}REACT on? hash? renew?></h2>
<pre class=sourcecode>
<elm>REACT on=<i>RVARlist</i></elm>
    <i>Content</i>
<elm>/REACT</elm></pre>
specifies that the given content should <i>react on</i> changes to any of the listed RVAR's. So whenever one or more of the RVAR's have changed, the content will be updated.

<p>
    With attribute <elm class=sourcecode>hash="<i>expressionlist</i>"</elm>, the given content will <i>only</i> be updated when an update is requested <i>and</i> the value of some expression(s) in the list has changed. This can improve performance.
</p>

<p>
    With attribute <code class=sourcecode>renew</code>, the given content will never be updated, but will be removed and rebuilt on every update request.
</p>
<p>
    An <elm>REACT</elm> element without content will not produce any DOM elements, and can be useful to insert <code>oncreate</code> or <code>onupdate</code> handlers in between elements.
</p>


<h2 id=COMPONENT><{}COMPONENT recursive? encapsulate?></h2>
<p>
<elm>COMPONENT</elm> introduces a new user-defined construct, or custom element.
<br>A component definition consists of a component <i>signature</i>, optionally one or more style sheets, scripts and local definitions, and a component <i>template</i>:
<pre class=sourcecode>
<{}COMPONENT recursive? encapsulate?>

  <{}SIGNATURE> <i>Signature</i> <{}/SIGNATURE>
  <comm>or just:</comm>
  <i>Signature</i>

  <{}STYLE &hellip;> &hellip; <{}/STYLE>&hellip;
  <{}SCRIPT &hellip;> &hellip; <{}/SCRIPT>&hellip;
  <{}DEFINE &hellip;> &hellip; <{}/DEFINE>&hellip;

  <{}TEMPLATE &hellip;> <i>Template</i> <{}/TEMPLATE>
  
<{}/COMPONENT>
</pre>
<ul>
    <li>
        The <a href=#Signatures><i>signature</i></a> describes how invocations of the component (or construct), called '<i>instances</i>', look like. The signature may specify <i>parameters</i> and <i>slots</i>.</li>
    <li>
        The <a href=#Templates><i>template</i></a> describes what content should be generated for each component instance. Inside the template, parameters are available as JavaScript variables, and slots are available as RHTML constructs. So the template may contain instances of the slots.</li>
    <li>
        <a href=#Instances><i>Instances</i></a> may or must specify values for each parameter, and contain blocks of RHTML code (or actually <i>templates</i>) for each slot.
    </li>
    <li>
        With attribute <code class="sourcecode">recursive</code>, the component can be recursive: the template may contain instances of the component itself. Also see <a href="#MutualRecursion">Mutual recursion</a>.
    </li>
    <li>
        With attribute <code class="sourcecode">encapsulate</code>, the generated content will be encapsulated, meaning mainly that the component can contain its own styling rules, independent of the main document.
        See <a href=#Encapsulate>encapsulate</a> for details.
    </li>
    <li>
        Component templates can contain nested component definitions.
    </li>
    <li>
        Component templates can use local variables defined outside of the component.
        <br>So a nested component definition can use the parameter values of the outer component.
    </li>
</ul>
<p>
    Note: RHTML component templates and slots are not the same as <a href="{MDN}Web/Web_Components">HTML web component templates and slots</a>. It's the same idea but a different syntax and implementation, both simpler and more powerful.
</p>


<h3 id=Signatures>Signatures</h3>
<p>
    The first element inside <elm>COMPONENT</elm> is its signature.
    <br>It is optionally surrounded by <elm>SIGNATURE</elm>.
    <br>E.g.:
    <pre #innerHTML="ColorCode(C1)"></pre>
    <ul>
        <li>
            The tag name of the signature element ('repeat' in this example) defines the name of the component.
        </li>
        <li>
            Attributes like <code><i>name</i></code>, <code>#<i>name</i></code>, or <code>@<i>name</i></code> of the signature element define the parameters of the component.
            <br>Instances of the component must have the same attributes, and these correspond to local variables inside the component template.
            <p>There are special cases:</p>
            <ul>
                <li>
                    Attributes with a question mark <code><i>name?</i></code> or with a nonempty default value <code><i>name</i>="<i>string</i>"</code> or <code><i>#name</i>="<i>expression</i>"</code> define <b>optional parameters</b>.
                    <br>When an instance doesn't have this attribute, then the specified default string or expression is used instead, or <code>undefined</code> when there is no default.
                    <p>
                        An empty <i>string</i>: <code><i>name</i>=""</code> is not recognized as a default value, because the HTML parser does not distinguish between a missing value and the empty string.
                        <br>To specify the empty string as default value, one must use an empty string <i>expression</i>: <code>#<i>name</i>=" '' "</code>.
                    </p>
                    <p>The default default value is <code>undefined</code>.</p>
                </li>
                <li>
                    Attributes <code><i>name</i></code> where <i>name</i> starts with "on" represent <b>event handlers</b>.
                    <br>Values are compiled as JavaScript, and the default default value is the empty handler.
                </li>
                <li>
                    Attributes <code>@<i>name</i></code> define <b>two-way parameters</b>.
                    <br>Their values must be valid <a href="#TwoWayBinding">assignment targets</a>.
                </li>
                <li>
                    An attribute prefixed with three dots <code>...<i>name</i></code> is a <b>rest parameter</b>. It must be the last parameter.
                    <br>All instance attributes that do not match a normal parameter are collected into this rest parameter, which can be passed on to an HTML element.
                </li>
            </ul>
        </li>
        <li>
            Each child element of the signature element defines a <i>slot</i> of the component.
            <br>These child elements are themselves signatures: slot signatures.
            <p>
                For each slot, component instances may have one or more child elements that should match the slot signature.
                <br>The slots are available <i>as constructs</i> within the component template.
            </p>
            <p>
                When building a component instance, the content of any instance child element that matches a slot becomes the (slot) template for the slot instances within the component template
            </p>
            <p>
                As slots have signatures, they can have parameters and slots themselves.
            </p>
        </li>
        <li>
            There is one special slot name, <elm>CONTENT</elm>. When a component signature contains a <elm>CONTENT</elm> slot, then all content of a component instance that does not match any other slot, forms a template for this special slot.
        </li>
    </ul>
</p>

<h3 id=Templates>Templates</h3>
The component template is tagged <elm>template</elm>. E.g.:
<pre #innerHTML="ColorCode(C2)"></pre>
<ul>
    <li>
        Parameters of the component (like <code>count</code>) are available <u>as local variables</u> inside the template.
    </li>
    <li>
        The value of the local variable <i>name</i> representing a two-way parameter <code>@<i>name</i></code> will be a new RVAR for each created instance of the component.
        <br>The RVAR value <code><i>name</i>.V</code> will be the value of the assignment target provided in the instance, and whenever a new value is assigned to the RVAR, that value will be assigned to the assignment target as well.
    </li>
    <li>
        Parameter names <u>may</u> be repeated in the template tag, like <elm>TEMPLATE #count</elm> or <elm>TEMPLATE count</elm>.
        <br>Or they may specify a local variable name, like: <elm>TEMPLATE #count=Count</elm>. This is useful when you want to have uppercase characters in the local variable name, because the parameter name itself, being an attribute name, is always seen as lowercase by the parser.
    </li>
    <li>Slots of the component (<elm>content</elm> in this case) are available <u>as constructs</u> inside  the template</li>
    <li>The template of a component with slots may contain <a href="#FORoverSlots">a special kind of FOR-loop</a> which iterates over the slot templates</li>
</ul>

<h3 id=Instances>Instances</h3>
A component is instantiated by a tag containing the component name:

<pre #innerHTML="ColorCode(C3)"></pre>

<h4>Parameter values</h4>
A component instance may/must have attributes that provide values for all optional/compulsory parameters of the template. There are four forms:
<ul>
    <li>By default, the value is specified as an interpolated string: <code><i>name</i>="<i>string</i>"</code></li>
    <li>When the name is prefixed with a hash mark, the value is computed as a JavaScript expression: <code>#<i>name</i>="<i>expression</i>"</code></li>
    <li>
        When <i>name</i> starts with "on", then the value is specified as a block of JavaScript statements, just like an event handler: <code><i>name</i>="<i>statements</i>"</code>
        <br>The value of the parameter will be the routine <code>function(event) \{ <i>statements</i> \}</code>.
    </li>
    <li>
        The value provided for a two-way parameter <code>@<i>name</i></code> must be a valid <a href="#TwoWayBinding">assignment target</a>.
    </li>
    <li>
        As with standard constructs, attribute names starting with an underscore "_" are ignored.
    </li>
</ul>
<p>
    When the component has a rest parameter, then the values specified by any remaining attributes are collected into that rest parameter. Otherwise it is an error when there are remaining attributes.
</p>

<h4>Slot templates</h4>
The component instance may contain templates for each of the slots of the component. So just as the component definition contains a component template that can be instantiated by a client, so the component instances may contain slot templates that can be instantiated within the component template.
<ul>
    <li>
        Slot templates are tagged by the slot name (not by <elm>template</elm>)
    </li>
    <li>
        Slot templates must be immediate children of the component instance. They are fixed at compile time, so they cannot be inside a <elm>CASE</elm> or some other construct.
    </li>
    <li>
        When the slot signature contains parameters, then these names <u>must</u> be repeated in the slot template tag.
    </li>
    <li>There may be multiple templates for the same slot. By default these are concatenated.</li>
    <li>
        When the component signature contains a slot named <elm>content</elm>, then all content of the component instance that is not some (other) slot template, forms a template for this content slot
    </li>
</ul>

Now in this case, the slot is named <elm>content</elm> indeed, so we can shorten the component instance to:
<pre #innerHTML="ColorCode(C4)"></pre>
</pre>
Note how the instance tag <elm>repeat</elm> carries both  the component parameter value <code>#count=7</code> and the slot parameter name <code>#num</code>.

<p>Putting it all together, we get:</p>
<demo #srctext=sampleComponent1></demo>


<h3 id="MutualRecursion">Mutual recursion</h3>
With the attribute <code class="sourcecode">recursive</code>, the component template may contain instances of the component itself. There is an <a href="#RecursiveSample">example</a> below.
<p>
    <i>Mutual recursion</i> between components means a series of <u>multiple</u> component definitions that may contain <u>instances of each other</u>.
</p>
<p>
    Mutual recursion is possible by combining multiple signatures and templates within a single <elm>COMPONENT</elm> construct, like this:
<pre #innerHTML="ColorCode(`<COMPONENT recursive>
    <SIGNATURES>
        <comp1 …> … </comp1>
        …
        <compn …> … </compn>
    </SIGNATURES>
    …
    <TEMPLATES>
        <comp1 …> … </comp1>
        …
        <compn …> … </compn>
    </TEMPLATES>
</COMPONENT>`)"></pre>
Notes:
<ul>
    <li>Each template is tagged by its component name.</li>
    <li>There must be exactly one template for each signature.</li>
    <li>When component parameters are repeated, they should be attached to the specific component name tag.</li>
    <li>This form of defining multiple components at once is possible for non-recursive components as well.</li>
</ul>


<h3 id=Encapsulate>Encapsulate</h3>
The <elm>COMPONENT</elm> tag may have an attribute <code class="sourcecode">encapsulate</code>.
<ul>
    <li>
        <i>Without</i> <code>encapsulate</code>, instances of the component are <i>replaced</i> by the output of the component template.
        <p>Any styling rules of the surrounding document apply to the component output as well, and vice versa.
        <br>To make styling rules apply only to the component content, use CSS class names.
    </li>
    <li>
        <i>With</i> <code>encapsulate</code>, <elm>COMPONENT</elm> defines a new <i>custom element</i>.
        <br>The output of the component template defines the appearance of the element, but is encapsulated inside, using the so-called <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>.
        <p>
            Any styling rules of the surrounding document do not apply to the encapsulated content, and vice versa. The component can have its own style sheet(s), independent of the main document.
            <br>Styling rules and inline styles specifically targeted at the custom element, however, are inherited by the encapsulated content.
        </p>
        <p>
            The generated custom element name is <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">required to contain a hyphen</a>.
            If the component name does not already contain a hyphen, then a prefix 'rhtml-' is prepended.
            <br>This concerns the generated output only, component instances use just the component name, but styling rules targeted at the custom element must use the prefix.
        </p>
    </li>
</ul>


<h3>More examples</h3>
<h4>To-do application</h4>
Here is a to-do application, which splits the collection of items into those done and not done. We use a component <elm>itemlist</elm> to show such a filtered list.
<demo #srctext=sampleTODO>
</demo>

<h4 id="RecursiveSample">A recursive component</h4>
<p>Components may be recursive, i.e. refer to themselve, when the attribute <code>recursive</code> is specified.
<br>Here is a recursive component, which images a JavaScript nested list of lists:</p>
<demo #srctext=sampleRecursion></demo>

<h4 id="Redefining">Redefining HTML elements</h4>
<p>Components may redefine HTML elements. To refer to the original element, add a dot to the tag name.
<br>Here is a component that redefines <elm>a</elm> to ensures that all links with no target and an external href, get a <code>target='_blank'</code> attribute:</p>
<demo #srctext=sampleRedefineA #bShow=true>
</demo>
To instantiate the original <elm>a</elm> element, write <elm>a.</elm>.

<h4>Slots within slots</h4>
<p>As there are no restrictions on slot signatures, slots can have slots themselves (subslots). So when a component template instantiates a slot, it may provide templates for its subslots, and these subslots can be instantiated within the slot templates of a component instance.
    <br>This is particularly useful for components with a <elm>CONTENT</elm> slot. The component may provide new or redefined constructs, that are available only within the contents of component instances, and that may provide interaction with the component.
</p>
<p>
    This documentation website uses such subslots to redefine <elm>H1</elm>, <elm>H2</elm> within the context of a particular page, so that the given section titles are automatically entered into the table of contents of that page.
</p>


<h4>A radio group component</h4>
HTML provides radio buttons <elm>input type=radio</elm> bearing a name and a fixed value, and buttons with the same name constitute a group.
<br>When they are within a <elm>form</elm>, and the form is submitted to the web server, then the value of the currently selected button within each group is sent to the server.

<p>
    For a reactive application, using <elm>form</elm> works a bit clumsily.
    <br>The following custom does a much better job; it allows one to bind an RVAR, or any other object property, directly to the selected radio button value, without needing a <elm>form</elm> and without repeating any code.
</p>

<demo #srctext="sampleRadioGroup" #bShow=true></demo>
Let me explain the somewhat complicated <elm>radiogroup</elm> signature.
<ul>
    <li>
        <elm>radiogroup</elm> has a parameter 'name' which will be the common name of all radio buttons in the group, and a two-way parameter '@value', that will provide <i>and</i> receive the value of the selected radio button.
    </li>
    <li>
        <elm>radiogroup</elm> has a slot <elm>content</elm> so that the component output can include the content of any radiogroup instance.
    </li>
    <li>
        Slot <elm>content</elm> has itself a slot <elm>radiobutton</elm>, that will be available as a new construct within the radiogroup instance contents.
    </li>
    <li>
        <elm>radiobutton</elm> has parameter '#value' that defines the value of the current button, and an optional 'onclick' handler so that component instances can specify this handler without overwriting the 'onclick' handler set by the component template, and a rest parameter '...rest' that will be passed on to the <elm>input type=radio</elm> radio button element.
    </li>
    <li>
        <elm>radiobutton</elm> has a slot <elm>content</elm>, that defines the label content for the current button.
    </li>
</ul>


<h2 id=FORoverSlots><{}FOR of> over component slots</h2>
When a custom construct (a component or a slot) has a slot <i>slot</i>, then instances of the construct may provide multiple templates for that slot.
<br>Now, inside the construct template, one can write:
<pre class=sourcecode>
<{}FOR of=<i>slot</i>>
    <i>Body</i>
<{}/FOR>
</pre>
When this template is instantiated, <i>Body</i> will be repeated for each provided <i>slot</i> template, and <i>slot</i> instances inside <i>Body</i> will be replaced by the output of just that template, rather than by the concatenation of all <i>slot</i> templates.
<p>
Here is a component which allows one to define tables column by column:
</p>
<demo #bShow=false #srctext=sampleTableMaker></demo>


<h2 id=INCLUDE><{}INCLUDE src></h2>
<code class=sourcecode><elm>INCLUDE src="<i>URL</i>"</elm><elm>/INCLUDE</elm></code>
allows you to include another RHTML file as if it were inserted into the main file.
<ul>
    <li>
        If the <elm>INCLUDE</elm> element has any content other than comments or whitespace, then that content is processed and <i>URL</i> is ignored.
        <br>(This allows a preprocessor to combine all files into one file.)
    </li>
    <li>
        Otherwise, the file is fetched from <i>URL</i> and compiled <i>asynchronously</i>: compiling the main file will continue while the included file is being fetched.
    </li>
    <li>
        <i>URL</i> may not use string interpolation, because the URL is needed at compile time.</p>
    </li>
    <li>
        <i>URL</i> may be a relative URL. In that case it is interpreted relative to the location of the <i>current</i> HTML file.
    </li>
</ul>

<p>
    To speed things up, you can insert a <a href="{MDN}Web/HTML/Link_types/preload">preload</a> link in the main document header:
</p>
<pre>
<{}link rel=preload href="<i>URL</i>" as=fetch crossorigin>
</pre>
("<code>crossorigin</code>" seems incorrect, but Google Chrome requires it.)

<h4>Using Server Side Includes</h4>
<p>
    A drawback of using <elm>INCLUDE</elm> may be that not all search engines will see the content of the included file.
    <br>Some engines, including Google, do execute JavaScript and will see the full document as it is built by OtoReact, while others won't.
    <br>So if you want all search engines to see the content of your document, then do not use <elm>INCLUDE</elm>.
    <br>An alternative might be to use server-side technology like <a href="{wiki}Server_Side_Includes">Server Side Includes</a> (SSI) to include your file, if your server supports it.
</p>
<p>
    It is possible to use both types of inclusion at once, if you have e.g. a production server that supports SSI and a development environment that does not:
</p>
<pre #innerHTML='ColorCode(`<include src="includefile.html">
    <`+`!--#include file="includefile.html"-->
</include>`)'></pre>
<ul>
    <li>
        In an environment that does not support SSI, the second line is ignored as a comment, and OtoReact will fetch the file and include its content.
    </li>
    <li>
        In an environment that supports SSI, the server will include the file in place of the second line, and:
        <ol>
            <li>All search engines will see its content</li>
            <li>OtoReact will process the included content rather than fetching the file separately.</li>
        </ol>
    </li>
</ul>


<h2 id=MODULE><{}MODULE id?></h2>
<elm>MODULE</elm> encapsulates a series of components, definitions, and other content, that may either be imported at other places using <elm>IMPORT</elm>.
<p>A <elm>MODULE</elm> can either be saved in a separate file, or it may be included anywhere in the main file.
<br>It may even be concatenated to the main file; the HTML parser will insert it inside the document body.</p>


<h2 id=IMPORT><{}IMPORT src defines? include?></h2>
<pre class=sourcecode>
<{}IMPORT async? src="<i>src</i>" defines?="<i>nameList</i>" include?>
    <i>Signatures</i>
<{}/IMPORT>
</pre>
imports a number of components defined in a <elm>module</elm>.
<p>
    The module may reside either:
</p>
<ul>
    <li>Anywhere in the main file with an <code>id</code> being exactly equal to <i>src</i></li>
    <li>Or in a separate file loaded from URL <i>src</i>.</li>
</ul>
There are two variants:
<ul>
    <li>
        With the <code class=sourcecode>async</code> option, the <elm>IMPORT</elm> element must contain full signatures of the imported components.
        <br>Compiling the document will continue with the provided signatures while the external file is being asynchronously fetched and compiled.
        <br>Only when one of the components has to be instantiated, will OtoReact wait for the completion of the import.
        <p>
            The listed signature need not be identical to the external signature, but must be 'compatible'. E.g., the order of parameters and slots may differ, and the external signature may have optional parameters and slots missing in the listed signature.
            <br>Default values may be different too; Otoreact will use the values listed in the <elm>IMPORT</elm> element.
        </p>
    </li>
    <li>
        Without the <code>async</code> option, the <elm>IMPORT</elm> element needs only specify the names of the imported components.
        <br>Compiling will still continue asynchronously, but as soon as the compiler encounters an invocation of one of these components, it will wait for the external file and get the signatures from there.
        <br>So one can import from multiple modules one after another, and these will still be fetched in parallel.
    </li>
</ul>
Furthermore:
<ul>
    <li>
        Components from the same module may be imported at multiple places and will be fetched and compiled only once, provided the URL is spelled exactly the same.
    </li>
    <li>
        Local variables from the main file are not visible within the module.
    </li>
    <li>
        When there is an attribute <code class=sourcecode>defines="<i>nameList</i>"</code>, then the names in the list, which must be defined as local variables in the module, are made available as local variables in the importing RHTML code.
    </li>
    <li>
        Any <elm>style</elm> definitions in the source module are added to the main document (even those within non-imported components, currently).
    </li>
    <li>
        Any non-declarative content of the module file is normally ignored.
        <br>If, however, the attribute <code class=sourcecode>include</code> is specified, then all content is instantiated at the place of the <elm>IMPORT</elm> element.
        <p>
            This is mainly useful for invisible content, like the definition of pop-up windows and datalists.
        </p>
    </li>
</ul>
Again, to speed things up, you can insert a <code>preload</code> link in the main document header.

<h2 id=RHTML><{}RHTML #srctext></h2>
<code class=sourcecode><elm>RHTML #srctext="<i>sourceExpr</i>"</elm><elm>/RHTML</elm></code> allows you to interpret dynamically generated text as Reactive HTML.
<p>After each build or update, when the text value of <i>sourceExpr</i> has changed, then this text is compiled as RHTML, built, encapsulated using <a href="{MDN}Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>, and shown.</p>
<p>The demo component on this page uses <elm>RHTML</elm>, of course.</p>
<p>Here you have an <elm>RHTML</elm> within the demo component, i.e. an <elm>RHTML</elm> within an <elm>RHTML</elm>:</p>
<demo #srctext=sampleRHTML></demo>

<h4>Caution</h4>
When you use <elm>RHTML</elm>, you should be cautious of client-side (DOM-based) <a href="{wiki}Cross-site_scripting#Server-side_versus_DOM-based_vulnerabilities">cross-site scripting</a> (XSS, or code injection) attacks, when the text content can be entered by (or influenced by) the user, as on this site.
<br>Client-side XSS is much less dangerous than server-side XSS, but still: don't ever use <elm>RHTML</elm> on sites with any security impact.

<h3>Demo HTML vs RHTML</h3>
In the following demo you can enter a piece of (R)HTML and compare how it is parsed and rendered by the browser without and with OtoReact processing.
<br>Note how OtoReact removes irrelevant white space.

<demo #srcText=demoRendering></demo>


<h2 id=RHEAD><{}RHEAD></h2>
Any child elements of <elm class=sourcecode>RHEAD</elm> are inserted into the current document header, and are updated or removed as needed.
<p>
    You can use this e.g. to set a dynamic document title or to add dynamic links, or to specify header content for documents created by <elm>DOCUMENT</elm>.
</p>


<h2 id=DOCUMENT><{}DOCUMENT></h2>
<pre class=sourcecode>
    <{}DOCUMENT name=<i>docName</i> params?="<i>nameList</i>" window?=<i>windowVar</i> encapsulate?>
        <i>content</i>
    <{}/DOCUMENT>
</pre>
allows you to define a separate document or form, that remains part of the same RHTML application.
<br>
<i>content</i> can be any RHTML code, which is not rendered immediately, but <i>docName</i> is defined as a local variable, bound to an object with the methods listed below, that will create a window either to be shown or printed.
<br>
Any scripts within <i>content</i> are executed within the same browsing context as the main document, and local RHTML variables from the main document are visible in local scripts within <i>content</i>.
<p>
    When <code class=sourcecode>params</code> is specified, then the given parameter names are available within <i>content</i> as local variables.
</p>
<p>
    When <code class=sourcecode>window</code> is specified, then the given <i>windowVar</i> is available within <i>content</i> as a local variable, and will be bound to the created window.
    <br>Note that global variable <code>window</code> refers to the main application window, but may be hidden by the local variable by specifying <code>window="window"</code>.
</p>
<p>
    The available methods are:
</p>
<dl>
    <dt><code><i>docName</i>.open(<i>target?</i>, <i>windowFeatures?</i>, ...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in a separate browser window, using the optionally specified <i>target</i> and <i>windowFeatures</i> as in <a href="{MDN}Web/API/Window/open"><code>Window.open()</code></a>, and parameter names bound to the given <i>args</i>.
        <br>The window gets an <code>onkeydown</code> handler that closes the window when the escape key is pressed.
        <br>The method returns a reference to the opened window.
        <br>All windows opened through this method are automatically closed when the user leaves the current RHTML application (through the <a href="{MDN}Web/API/Window/pagehide_event">pagehide event</a>).
    </dd>
    <dt><code><i>docName</i>.print(...<i>args</i>)</code></dt>
    <dd>
        The construct content is rendered in an invisible browser window with parameter names bound to the given <i>args</i>, and its browser print dialog is opened.
        <br>After the user has closed the print dialog, the invisible window is closed as well.
    </dd>
    <dt><code><i>docName</i>.closeAll()</code></dt>
    <dd>
        This closes all child windows opened through <code><i>docName</i>.open</code>.
        <p>
            You could for example use this in an <code>ondestroy</code> handler, to close all child windows when the document definition is removed from the DOM-tree: <pre #innerHTML='ColorCode(`<document name=docName ondestroy="docName.closeAll()">`)'></pre>
        </p>
    </dd>
</dl>

By default, all styling rules attached to the parent document are copied to the new document, but with the option <code class=sourcecode>encapsulate</code> no rules are copied.
<br>Any <elm>style</elm> sheets within the <elm>DOCUMENT</elm> content are excluded from the parent document, and attached to each new child window. 
<br>Or you can use <elm>RHEAD</elm><elm>LINK &hellip;</elm><elm>/RHEAD</elm> to link an external style sheet.

<demo #srctext=sampleDocument></demo>
