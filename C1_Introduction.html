<h1 id=Introduction>Introduction</h1>

<div style="display: grid; grid-template-columns: 1fr 1fr ; align-items: center; justify-items: center; margin-top:-1em; width:100%">
    <div class=sample 
        style="min-width: 325px; min-height: 110px;" 
        id=sampleGreeting>
        <RHTML #srctext=sampleGreeting></RHTML>
    </div>
    <div style="height: fit-content; width: fit-content;">
        <RHTML #srctext=sampleTicTacToe></RHTML>
    </div>
</div>

<p>
    '<i>Reactive web applications</i>', or '<a href="{wiki}Single-page_application">Single Page Applications</a>', are web applications that, when possible, react immediately on user input, timer events etc, or the receival of server data requested by the application, instead of having the web server generate and send a new HTML page.
    <br>This results in both a much better user experience and much less server load.
    <br>Two tiny examples you see above; please enter some data.
</p>
<p>
    Reactivity is attained by means of JavaScript programming code running inside the web browser. The JavaScript code has to manipulate the so-called "DOM" ("Document Object Model"), which is the internal object model of a web page ("document").
    <br>Writing such JavaScript by hand can get quite complicated and might result in very cluttered programming code. A <a href="{MDN}Learn/Tools_and_testing/Client-side_JavaScript_frameworks"><i>framework</i></a> makes it much easier to create reactive web applications.
</p>
<p>
    <b>OtoReact</i></b> is a small and fast framework to attain reactivity by loading so-called <b>Reactive HTML</b>, or <b>RHTML</b>, <i>straight into the browser</i>:
</p>
<ul>
    <li>Reactive HTML is parsed by the browser itself, and compiled and executed by OtoReact within milliseconds.
    <li>Reactive HTML is easy to learn, and one doesn't need to install a compiler, a bunch of libraries, node, or <i>anything</i>.
        <br>Just a text editor and access to a web server (<i>any</i> web server) suffice.
    <li>Reactive HTML makes it easy to build dynamic <a href="#colorTable">pages based on data</a>, even if no reactivity is needed.
    <li>Reactive HTML makes it easy to follow the <a href="{wiki}Model–view–controller"><i>Model-view-controller</i></a> design pattern, separating your data model and program logic from the presentation.
    <li>Reactive HTML has a powerful <a href="#Component">component system</a>, <a. href="./routing" #onclick="reroute">URL routing</a.>, <a href="#onerror">global error handling</a>, some <a href="#Persistence">persistence</a>, et cetera.
    <li>OtoReact does not modify any native objects (prototypes), and can be used for fragments of a larger application, meaning that it can easily be combined with other tooling.
</ul>

<h3>Samples</h3>
<h4>What's your name</h4>
<p>
    The tiny example above on the left is the result of the following piece of Reactive HTML:
</p>
<pre class=sourcecode #innerText=sampleGreeting></pre>
Explanation:
<ul>
    <li>
        <elm>define rvar='yourName'</elm> introduces a "reactive variable" <code>yourName</code>, that can contain state information of the application. <code>yourName.V</code> denotes the value of the variable.
    </li>
    <li>
        <code>@value="yourName.V"</code> binds the value of the reactive variable to the value of the input element. Whenever the input element receives input, OtoReact will update the reactive variable and the rendered document.
    </li>
    <li>
        <elm>if cond=&hellip;</elm> is an RHTML conditional. Whenever the JavaScript condition is <a href="{MDN}Glossary/Truthy">truthy</a>, in this case when <code>yourName.V</code> is non-empty, then the body of the conditional is rendered.
    </li>
    <li>
        <code>\{yourName.V\}</code> and <code>\{yourName.V.length\}</code> are embedded expressions. The rendered document will contain the value of the expression between the braces.
    </li>
</ul>

<h4>Tic-Tac-Toe</h4>
The Tic-Tac-Toe source code is shown <a href="#reacton">here</a>.


<h4>Working with server data</h4>
<p id=colorTable>Here is an example of dynamically building a table based on server data, with a bit of animation as well:</p>
<demo #srctext="sampleServerData2" #bShow=false #editable=true></demo>                                


<h3>Remarks</h3>
<h4>Other frameworks</h4>
<p>
    There exist quite a number of alternative libraries and frameworks to make it easier to build reactive web applications. I distinguish two main categories:
</p>
<ol>
    <li>
        Some, like <a href="https://jquery.com/">JQuery</a> and <a href="https://reactjs.org/">React</a>, offer tools to make it easier to manipulate the DOM.
        <br>All manipulation is still done from within the JavaScript you write, and you need a good understanding of DOM manipulation and JavaScript in general.
        <br>The respective libraries can in some cases be loaded straight into the browser without compilation.
    </li>
    <li>
        Others, like <a href="https://angular.io/">Angular</a> and <a href="https://svelte.dev/">Svelte</a>, make a clean separation between the programming code and presentation. The JavaScript you write contains the data model and data manipulation you need; the actual web page is described by a template file containing HTML enriched with directives and other stuff.
        <br>You don't need to write code to manipulate the DOM at all anymore; this is done by the framework.
        <br>The source code files have to be compiled on you development machine. You need to install the compiler, and quite some modules for each application (which for Angular may take more than 1GB per application).
    </li>
</ol>
<p>
    Reactive HTML combines features of both approaches, giving you the advantages of describing the desired reactive layout by a HTML template, separate from your programming code, without the hassle of installing and using a compiler and managing quite a number of configuration files, and you need just a basic understanding of JavaScript.
</p>

<h4>Reactive !== Responsive</h4>
<i>Reactive</i> is not the same thing as <i>responsive</i>, though there is some overlap.
<br><a href="{wiki}Responsive_web_design">Resonsive web design</a> is a phrase used to indicate web pages that adapt themselves to the device they are viewed on.
<p>
    This document for example changes its layout when being printed or viewed on a narrow screen: the table of contents moves to the top, and on a mobile device font sizes are adapted.
</p>
<p>
    Responsiveness is usually attained by using <a href="{MDN}Web/CSS/@media">CSS media queries</a>, which is perfectly possible in Reactive HTML.
    <br>When you get stuck with media queries, then reactivity may come to the rescue, to make changes to the CSS not possible with media queries.
</p>

<h4>No server-side functionality</h4>
OtoReact does not provide server-side functionality. You need other tooling for that, like Node.js (+ Express), Python, PHP, .Net, or perhaps you can use existing web API's.

<h2>Setup</h2>
<ol>
    <li>
        Download <a href="./OtoReact.js" download>OtoReact.js</a> and place it somewhere on your server.
        <br>It's just 40 kilobyte.
    </li>
    <li>
        Import the OtoReact compiler into your application:
        <pre class=sourcecode>import \{ RCompile \} from './OtoReact.js';</pre>
    </li>
    <li>
        Invoke the compiler on the part(s) of your page you wish to be reactive, e.g.:
        <pre class=sourcecode>RCompile( document.body );</pre>
        Both code lines can either be placed right into you HTML file:
        <pre>
<{}script type=module>
    import \{ RCompile } from './OtoReact.js';
    RCompile( document.body );
<{}/script></pre>
        , or inside a JavaScript (or TypeScript) module you load from your HTML file.
    </li>
    <li>
        You may also want to hide all or part of your application until it has been built, e.g. by using:
    <code class=sourcecode><{}body hidden></code>.
        <br>RCompile will unhide its argument after it has been built.
    </li>
</ol>
That's all!

<h2 id=StringInterpolation>String Interpolation: text with embedded expressions</h2>
All text content and all HTML attributes inside RHTML code, except scripts, expressions and event handlers that are already JavaScript, may contained embedded JavaScript expressions between braces.
<br>This is called <a href="{wiki}String_interpolation">string interpolation</a> or, in JavaScript terminology, 'template literals'.
<p>
    The expressions are evaluated, converted to string, and inserted <i>as text</i>; there is absolutely no risk of <a href="{wiki}Code_injection">code injection</a>.
</p>
<p>
    To include a normal pair of braces in RHTML, at least one of them must be escaped with a backslash.
</p>
<p>
    You may omit the expression, like <code>\{}</code>, which comes in handy if you want the parser to not recognize an HTML tag:
</p>
<demo #srctext="sampleBraces"></demo>
<p>
    You can modify the snippet of source code above and see the result immediately.
    <br> (This interactive demo is itself defined as an RHTML component.)
</p>
<p>If you prefer, you may add a dollar sign as in JavaScript, like <code>1 + 1 = \${1 + 1}</code>.</p>

<p>If you set the <a href="#Options">option</a> 'bDollarRequired', then the dollar sign becomes compulsory, and you can write normal braces without a backslash.</p>

<p>Within JavaScript, you can use the JavaScript syntax for <a href="{MDN}Web/JavaScript/Reference/Template_literals">template literals</a>, including backquotes and dollar signs:</p>
<pre>let x = `Some text ${<i>expression</i>} et cetera`;</pre>

<h2>RHTML Constructs Overview</h2>
<p>RHTML defines a number of new <i>constructs</i>, which dynamically build your HTML page:</p>
<ul>
    <li>
        <a href=#Define><elm>DEFINE</elm></a> introduces a local variable or reactive variable
    </li>
    <li>
        <a href=#If><elm>IF</elm></a> specifies a conditional block of RHTML
    </li>
    <li>
        <a href=#Case><elm>CASE</elm></a> specifies a series of alternative conditional blocks of RHTML
    </li>
    <li>
        <a href=#For><elm>FOR</elm></a> specifies a repeating block of RHTML, with a number of additional features
    </li>
    <li>
        <a href=#Component><elm>COMPONENT</elm></a> defines a user-defined construct.
        <br>Components may be recursive and may have <i>slots</i>, which are themselves full-fledged constructs.
    </li>
    <li>
        <a href=Import><elm>IMPORT</elm></a> asynchronously imports components defined in a separate file (a <i>module</i>) into your application
    </li>
    <li>
        <a href=#Include><elm>INCLUDE</elm></a> asynchronously includes a separate RHTML file into your application
    </li>
    <li>
        <a href=#RHTML><elm>RHTML</elm></a> dynamically compiles a string as RHTML.
        <br>This is used in the demo component you see on this page.
    </li>
    <li>
        <a href=#React><elm>REACT on</elm></a> optionally allows you to specify which blocks of RHTML should react on which variables, optimizing your application.
        <br>The RHTML attribute <code>reacton</code> does the same thing.
    </li>
</ul>
Note: We write construct names in uppercase and attribute names in lowercase here, but as in HTML, both are case independent.


<h2>RHTML functions</h2>
The OtoReact module makes the following functions available for import. They are added to the global environment as well.
<ul>
    <li>
        <code>RCompile(HTMLElement, options?)</code> compiles and builds the given HTMLElement as RHTML, using the given <a href=#Options>options</a>.
    </li>
    <li>
        <code>RBuild()</code> builds any previously compiled HTMLElements, in case the option 'bNoBuild' was used with <code>RCompile</code>.
    </li>
    <li>
        <code>RVAR(name?, initialValue?, store?)</code> creates a reactive variable
    </li>
    <li>
        <code>reroute()</code> and <code>docLocation</code> are used with <a href=#URLRouting>URL routing</a>
    </li>
    <li id=rangeFunction>
        <code>range(start?, stop, step?)</code> yields an iterable range of numerical values, analogous to the <a href="https://docs.python.org/3/library/stdtypes.html#range">Python range type</a>. You can use this with <elm>FOR</elm>.
    </li>
    <li id=RFetch>
        <code>RFetch(resource, init?)</code> is the same as <a href="{MDN}Web/API/fetch"><code>fetch(resource, init?)</code></a>, except that it throws an error when an HTTP error status is  received.
    </li>
</ul>
The question marks indicate optional arguments.
<p>
    All of these are exported by the OtoReact module. TypeScript type declarations are available on the <a href="download" #onclick=reroute>download page</a>.
</p>


<h2 id=Variables>Local and global variables</h2>


<h2 id=RVAR>RVAR: Reactive VARiable's</h2>
<p>
    Reactive variables (RVAR's) are objects containing variable data on which RHTML elements may react.
    <br>Anytime the value of an RVAR changes, the reacting elements will be updated.
</p>
<p>
    RVAR's are created either by calling <code class=sourcecode>RVAR(name?, initialValue?, store?, subscriber?, storename = `RVAR_$\{name\}`)</code> from JavaScript, or by using the <a href=#define><elm>define rvar</elm></a> construct.
    <br>The created RVAR is returned and may be stored in a local variable.
</p>

<h4>RVAR arguments</h4>
<dl>
    <dt><code>name</code></dt>
    <dd>
        If you supply a <code>name</code>, the RVAR will be registered in the global environment under that name and will be visible anywhere.
        <br>So if you write:
        <pre>
    <{}script type=module>
        const A = RVAR('B');
        &hellip;</pre>
        , then it will be available as <code>A</code> just inside this script, and also as <code>B</code> anywhere (though normally one wouldn't use different local and global names).
    </dd>
    <dt><code>initialValue</code></dt>
    <dd>
        Provides the initial value of the RVAR.
        <br>When <code>initialValue</code> is a <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>, then the value of the RVAR will initially be <code>undefined</code>, and when the promise resolves to a value, then the RVAR will be set to that value.
    </dd>
    <dt><code>store</code></dt>
    <dd>
        Provides simple persistence functionality, see <a href="#Persistence">Persistence</a>.
    </dd>
    <dt><code>subscriber</code></dt>
    <dd>
        A routine which is <a href="#Subscribe">subscribed</a> to the RVAR.
    </dd>
    <dt><code>storename</code></dt>
    <dd>See <a href="#Persistence">Persistence</a>.</dd>
</dl>

<p>
    You may or must inform OtoReact which fragments of RHTML should react on which RVAR's, by using the <a href=#React><elm>REACT</elm> element</a> or the <a href=#reacton><code>reacton</code> attribute</a>, see below.
    <br>For RVAR's created by calling <code>RVAR()</code>, this is necessary.
    <br>For RVAR's created by <elm>define rvar</elm>, if there are no explicit react's <u>and</u> no other subscribers, then all RHTML code where the RVAR is visible <u>will implicitly react</u> on the RVAR.
</p>

<h4>Properties and methods</h4>
<p>A reactive variable <code>x</code> is an object, distinct from the value of the variable. It has the following properties and methods:</p>
<dl>
    <dt><code class=sourcecode>x.V</code></dt>
    <dd>
        To get or set the value of an RVAR <code>x</code>, one writes <code>x.V</code>.
        <br>When <code>x.V</code> is set to a different value than it had, the variable is marked as dirty, and all RHTML code that reacts on it will be updated.
    </dd>
    <dt><code class=sourcecode>x.U</code></dt>
    <dd>
        When you modify not the value of a variable, but properties of the value, you may want the variable to be marked as dirty as well.
        <br>You can do this by writing <code class=sourcecode>x.U</code> to access the value of the variable.
        <br>If, e.g., <code>x.V</code> is an array, you can write <code>x.U.push(e)</code> to add an element <code>e</code>, and the DOM will react on the modified array. So you don't have to assign to <code>x.V</code> to trigger a reaction.
        <p>
            Setting <code>x.U</code> sets the value of <code>x</code> and marks it as dirty at all times.
        </p>
    </dd>
    <dt><code class=sourcecode>x.SetDirty()</code></dt>
    <dd>
        The RVAR can be explicitly set dirty by calling <code>x.SetDirty()</code>.
    </dd>
    <dt id=Subscribe><code class=sourcecode>x.Subscribe(subs, bImmediate?, bInit = bImmediate)</code></dt>
    <dd>
        Routine <code>subs</code> is registered as a subscriber to <code>x</code>, so it will be called whenever <code>x</code> has been set dirty.
        <br>When <code>bImmediate</code> is truthy, <code>subs</code> will be called <i>immediately</i> every time <code>x</code> is being set dirty; otherwise it will be called once at the next event cycle.
        <br>When <code>bInit</code> is truthy, then <code>subs</code> will be called directly when it is registered. The default value for <code>bInit</code> is the value of <code>bImmediate</code>.
    </dd>
    <dt><code class=sourcecode>x.UnSubscribe(subs)</code></dt>
    <dd>
        Unregisters a routine <code>subs</code> previously registered as a subscriber to <code>x</code>.
    </dd>
    <dt><code class=sourcecode>x.SetAsync(value)</code></dt>
    <dd>
        Sets the value of <code>x</code> either synchronously, or asynchronously when <code>value</code> is a <a href="{MDN}Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
    </dd>
    <dt><code class=sourcecode>x.Set</code></dt>
    <dd>
        Provides a routine that sets the value of <code>x</code>, i.e. <code>v => x.SetAsync(v)</code> (or <code>x.SetAsync.bind(x)</code>).
        <p>
            This is handy to create an errorhandler. E.g., if <code>errMsg</code> is an RVAR that should receive error messages, then you can write <code>doSomething().catch(errMsg.Set)</code> to catch the errors of some asynchronous routine, or you can add an attribute <code>#onerror="errMsg.Set"</code> to catch all errors within a block of RHTML.
        </p>
    </dd>
</dl>


<h4 id=Persistence>Persistence</h4>
When you provide a <code>store</code> parameter to <code>RVAR()</code> or to <elm>define rvar</elm>, then the variable value will be retrieved from that store when the variable is created, and stored at every update.
<p><code>store</code> can be:</p>
<ul>
    <li><code>sessionStorage</code>, meaning that the value will be restored when the user reloads the page, or leaves it and returns again while staying in the same browser window</li>
    <li><code>localStorage</code>, meaning that the value will be preserved in local browser storage and restored when the user returns to the same site in the same browser on the same machine</li>
    <li>Any other object that supports the <code>setItem</code> and <elm>getItem</elm> methods of the <a href="{MDN}Web/API/Storage">Storage interface</a>.
    </li>
</ul>
<p>The RVAR must have a unique <code>storename</code>; the default is <code>`RVAR_$\{name\}`</code>.</p>

<p>
    An as example, enter your name at the <a href=#Introduction>top of this introduction</a>, reload the page, and note that your name has persisted.
</p>

<h2>Scripts in RHTML</h2>
<p>
    Scripts can be included anywhere using the <elm>SCRIPT</elm> element just as in HTML.
    <br>They will be executed once, but the moment of execution depends on the script type, see <a href="#Scripts">Scripts</a>.
</p>
<p>
    Scripts in OtoReact can export variables, so that these variables are locally visible in RHTML code.
</p>
<p>
    A variabe declared in a script is instantiated only once, as always in JavaScript. 
    <br>If you need multiple instances, then you put them inside a class, and use <elm>DEFINE</elm> to create local instances of the class.
    <br>There is an example of this in the <a href="#TicTacToe">Tic-Tac-Toe demo</a> below.
</p>
<p>
    See <a href="#Scripts">Scripts</a> for details about <elm>SCRIPT</elm> in RHTML.
</p>


<h2>Style Sheets</h2>
Style sheets can be included anywhere using the <elm>STYLE</elm> element as in HTML. OtoReact will move them to the document head so they don't get repeated or lost.
<p>
    Styles sheets have global effect, except inside an 'isolated' <a href=#Component>component</a> or inside <elm>RHTML</elm> text.
    <br>There is no provision for local style sheets yet. To use local styling, just add local class names to each styling rule.
</p>
<p>
    Style sheets inserted with <elm>STYLE</elm> <u>cannot contain interpolated strings</u>, because the HTML parser does not allow that.
    <br>However, OtoReact allows to use <a href=#StyleTemplate><elm>STYLE.</elm></a> to build style sheets with string interpolation.
</p>


<h2>How It Works</h2>
OtoReact's <code>RCompile</code> does not, as one might perhaps expect, translate the whole chunk of RHTML into one large string of JavaScript.
<br>Rather:
<ol>
    <li>
        Each snippet of JavaScript is compiled <i>separately</i> into a routine, by offering it to JavaScripts <code>eval</code> function (in global scope, of course).
        <br>E.g., an RHTML property expression <code>a+b</code> is compiled by calling <code>eval("([a,b]) => (a+b)")</code>.
        <p>OtoReact does not itself parse and analyse the JavaScript, so it is unaware which variables are actually used and which are not.</p>
    </li>
    <li>
        While traversing the RHTML document tree, all these tiny routines are combined by JavaScript functions into "builder" routines, which can build ór update the DOM tree according to the RHTML. Each RHTML source node corresponds to a separate builder routine.
    </li>
    <li>
        The root builder routine is called to perform the initial build.
    </li>
    <li>
        Each time a builder routine is called to build a DOM node, or a range of DOM nodes, it creates a so-called 'Range' object that refers to the created range of nodes and contains other meta-information as needed. This information is used when the builder routine is called again to update the same range of nodes.
    </li>
    <li>
        While building, any part of the resulting DOM tree which is marked to react on some RVAR, is registered with the RVAR <i>together</i> with its local 'environment' containing the value of all local variables at that point, <i>and</i> a local builder routine which can update just that part of the DOM tree.
    </li>
    <li>
        After the DOM tree has been built, the browser engine will compute the graphical document layout and graphically render its contents.
        <br>It will do so again anytime the DOM tree changes.
    </li>
    <li>
        Whenever some RVAR is marked dirty, it will schedule (by <a href="{MDN}Web/API/WindowOrWorkerGlobalScope/setTimeout"><code>setTimeout</code></a>) all reacting DOM tree parts to get updated by their registered builder routine in its registered environment.
        <br>The updating takes place at the next 'event cycle'.
        <br>While updating, all present HTML elements will remain in place as much as possible, so that any elements that had received focus or input data will keep that.
    </li>
</ol>


<h2>Limitations inflicted by the parser</h2>
Using the browser HTML parser inflicts us some limitations, as it isn't tailored for RHTML. Such as:
<ul>
    <li><b>Re-arranged elements</b>
        <br>The HTML parser forces elements to be arranged according to HTML rules, and will <i>silently</i> rearrange them if they are not.
        <br>Notably:
        <ul>
            <li>Table-related elements TABLE, THEAD, TBODY, TFOOT, TR may only contain appropriate children.
                <br>The same holds for elements INPUT and SELECT, and perhaps others.
                <br>If, e.g., a <elm>table</elm> would contain a <elm>for</elm> loop containing a <elm>tr</elm>:
                <pre><{}table>
    <{}for let=x #of=&hellip;>
        <{}tr> &hellip; \{x} &hellip; <{}/tr>
    <{}/for>
<{}/table></pre>
                , then the (Chromium) parser will move the <elm>for</elm> <i>before</i> the <elm>table</elm>, while leaving the <elm>tr</elm> inside.
                <br>Thus OtoReact sees:
<pre><{}for let=x #of=&hellip;>
<{}/for>
<{}table>
    <{}tr> &hellip; \{x\}&hellip; <{}/tr>
<{}/table></pre>
                , and will give a misleading error about <code>x</code> being undefined.
                <br>To get the loop right, OtoReact allows you to put one (or more) dots after any tag name, so the parser won't interfere:
<pre><{}table.>
    <{}for let=x #of=&hellip;>
        <{}tr.> &hellip; \{x\} &hellip; <{}/tr.>
    <{}/for>
<{}/table.></pre>
                When compiling, the dots will be removed.
            </li>
            <li>
                The paragraph-element <elm>p</elm> does not allow block-level elements inside, but allows unknown elements.
                <br>Thus, if you write
<pre><{}p> &hellip; 
<{}if &hellip;><{}ul> &hellip; <{}/ul><{}/if></pre>
                , without closing the <elm>p</elm>, either because you know the parser will automatically close it when needed, or because you didn't know <elm>ul</elm> is not allowed inside <elm>p</elm>, then the parser will silently close the <elm>p</elm> <i>after</i> the unknown <elm>if</elm>, and the <elm>ul</elm> ends up <i>outside</i> the <elm>if</elm>, without you or OtoReact being informed:
<pre><{}p> &hellip; <{}if &hellip;><{}/if><{}/p>
<{}ul> &hellip; <{}/ul></pre>
                To avoid this, make a habit of always closing all elements.
            </li>
        </ul>
    </li>

    <li><b>Attribute names are always lowercase</b>
    <br>
        As attribute names in HTML are case-insensitive, the parser makes them all lowercase.
        <ul>
            <li>As RHTML sometimes uses attribute names as bound variables, such variables will be lowercase, even if you wrote them with uppercase, and OtoReact can't warn you about this.</li>
            <li>There is also a feature for conditional classes (<code>#class:someclass="someBoolean"</code>), which will only work for class names in lowercase.</li>
            <li>RHTML allows you to use attributes to set DOM properties, but DOM property names are case sensitive. So Otoreact receives the property name in lowercase and has to restore proper casing. It is conceivable that the restored casing is incorrect for some property.</li>
        </ul>
    </li>
    <li><b>Missing error messages</b>
    <br>
        There are more cases where the browser doesn't inform you of errors, which may result in strange behaviour.
    </li>
</ul>
<p>I imagine Reactive HTML one day being natively supported by the browser. In that case, these limitations can be lifted.</p>

<h3>Problem solving</h3>
<ul>
    <li>
    When you get weird errors, you may have forgotten to add dots where needed.
    <br>Otherwise, you may want to check how the browser has parsed your document:
    <ol>
        <li>Outcomment or remove your compiler invocation: <code>// RCompile(&hellip;)</code></li>
        <li>Reload your application</li>
        <li>Inspect the parsed DOM-tree using your browsers development tools. Either:
            <ul>
                <li>Right click in your document and select 'Inspect'</li>
                <li>Press F12 or Ctrl-Shift-I and select tab 'Elements' (Chrome) or 'Inspector' (Firefox)</li>
            </ul>
        </li>
    </ol>
    </li>
    <li>
        When your application doesn't react on events, you may have forgotten some <code>reacton</code> attribute.
    </li>
    <li>
        Errors while building the DOM are by default inserted into the DOM output, but may sometimes be invisible or get overlooked. Look in the development console to be sure you haven't missed any error messages, or enable option <code>bAbortOnError</code>.
    </li>
    <li>
        When an event handler or some other piece of JavScript doesn't work as expected, you might insert the <a href="{MDN}Web/JavaScript/Reference/Statements/debugger"><code>debugger</code> statement</a>, to get a breakpoint at that point when the browser development tool is opened.
    </li>
</ul>
