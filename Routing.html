<pageLayout>
    <pageHead>
        <span class=OtoRed>Routing</span> through the <span class=OtoRed>OtoReact</span> framework
    </pageHead>
    
(Note: This documentation is unfinished.)
<h2>What is URL Routing</h2>
    
<p>
    Web applications often contain multiple pages for different purposes, for example an inventory list, inventory details for each item, a customer list, etc.
    
<p>
    A traditional <i>server-side</i> web application utilizes <i>different URLs</i> (page addresses in the navigation bar) to navigate between different pages. 
<p>
    A single <i>client-side</i> web application can blazingly fast provide all these pages by changing its internal state without using different URLs.
    <br>Actually, as the application is fetched as a single document from the server, it natively <i>has</i> just a <i>single URL</i>.
</p>
However, utilizing separate URLs has advantages to the user:
<ol>
    <li>Pages can be individually linked, saved as bookmarks, shared by email or social media, etc.
    <li>The application can be refreshed while staying at the same page
    <li>The browsers back and forward buttons can be used to navigate back and forth
</ol>
Now, <i>URL routing</i> means routing different URLs to different virtual pages, while in the background remaining in one and the same (single page) application.
<p>
    This page itself is presented to you using URL routing. You can quickly move back and forth without anything being fetched from the server, not even from cache.
</p>

<h2>Variants of URL routing</h2>
An (absolute) URL (<a href="{wiki}URL">Uniform Resource Locator</a>), like "https://otoreact.dev:80/some/path?param1=A&amp;param2=B#someHash", consists of several parts that can be used for routing.
<ul>
    <li>
        The 'protocol', 'host', and optional 'port', together called the 'origin' "https://otoreact.dev:80", must remain the same for all pages in an application, and cannot be used for routing.
    </li>
    <li>
        The 'pathname' "/some/path"
    </li>
    <li>
        The optional 'search' string "?param1=A&amp;param2=B"
    </li>
    <li>
        The optional 'hash' or 'fragment' "#someHash" could be used for routing too.
    </li>
</ul>

<h2>How is URL Routing achieved</h2>
<ol>
    <li>
        When using the pathname for routing, then the web server has to be configured to serve the same web application on different pathnames.
    </li>
    <li>
        When the application is opened with a specific URL, it has to "route" the URL to the correct page definition.
    </li>
    <li>
        When the user clicks on a link to a different internal page, then:
        <ol>
            <li>The page request has to be intercepted, so that the browser does not request a new page from the server</li>
            <li>The application state has to be modified to show the correct page</li>
            <li>The new URL has to be shown in the browser address bar and recorded in browser history</li>
        </ol>
    </li>
    <li>
        When the user hits the browser back or forward button, the browser will automatically update the shown URL, but the application must modify its state to show the corresponding page
    </li>
    <li>
        When using the pathname for routing and not only its last segment, then relative links on the page have be avoided, as they depend on the current pathname except its last segment.
    </li>
</ol>

<h2>How does OtoReact facilitate URL Routing</h2>



<script nomodule defines="ColorTable,toHex,rotating,Rotate,lineh" >
    // Here we store the data. Columns are:
    // name:string, red:number, green:number, blue:number.
    const ColorTable = RVAR('', []), 
        lineh=RVAR('',100);     // Relative height of first line
    
    /* Fetch the data! */
    fetch("webColors.json").then(async response => {
        if (response.ok)
            ColorTable.V = JSON.parse(await response.text());
    });
    
    /* Utility for 2-digit hex code */
    function toHex(n){ 
      return n.toString(16).toUpperCase().padStart(2,'0');
    }
    
    /* Rotation */
    let rotating=RVAR('', false);
    async function Rotate() {
        rotating.V = !rotating.V;
        while (rotating.V) { 
            // Animating the first row
            for (lineh.V=100; lineh.V>0; lineh.V-=25)
                await new Promise(r => setTimeout(r, 125));

            // Modifying the data model triggers a page update:
            ColorTable.U.push(ColorTable.V.shift());
        }
    }
    </script>
    
    <style> /* Styling */
        table.colorTable td {
        padding: 0px 4px;
        text-align: center;
        max-width: 8em; overflow:hidden;
        }
    </style>
    
    <div style="height:50ex; overflow-y:scroll;">
      <!-- Now we build our table! 
        The dots are needed because HTML does not allow <FOR> as a
        child of <TABLE>. OtoReact removes these dots. -->
      <table. class=colorTable>
        <!-- Table caption -->
        <caption.>Web Colors 
            <button onclick="Rotate();" reacton=rotating style.float=right>
                {rotating.V ? 'Stop' : 'Rotate'}
            </button>
        </caption.>
        <!-- Column headers -->
        <tr.>
          <th.>Name</th.>
          <th.>R</th.><th.>G</th.><th.>B</th.>
          <th.>Hex</th.>
        </tr.>
        <!-- Detail records -->
        <FOR let=C of="ColorTable.V" index=i
            _comment="Optimization:" reacton="ColorTable,lineh" key=C>
          <tr. style.backgroundColor="rgb({C.red},{C.green},{C.blue})" 
               #style.color="C.green<148 ? 'white' : 'black'"
               #style.lineHeight="i==0 ? `${lineh.V}%` : null"
          >
            <react hash=C>
                <td.>{C.name}</td.>
                <td.>{C.red}</td.><td.>{C.green}</td.><td.>{C.blue}</td.>
                <td.>
                #{toHex(C.red)}{toHex(C.green)}{toHex(C.blue)}
                </td.>
            </react>
          </tr.>
        </FOR>
      </table.>
    </div>

</pageLayout>